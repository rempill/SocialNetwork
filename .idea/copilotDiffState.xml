<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/UI/ConsoleUI.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/UI/ConsoleUI.java" />
              <option name="originalContent" value="package UI;&#10;&#10;import domain.*;&#10;import errors.RepoError;&#10;import errors.ValidationError;&#10;import service.NetworkService;&#10;&#10;import java.time.DateTimeException;&#10;import java.time.LocalDate;&#10;import java.time.format.DateTimeFormatter;&#10;import java.util.Arrays;&#10;import java.util.List;&#10;import java.util.Scanner;&#10;&#10;/**&#10; * Simple console-based user interface for interacting with the NetworkService.&#10; * Provides commands to add/remove users, manage friendships and display&#10; * network-related information.&#10; */&#10;public class ConsoleUI {&#10;    private NetworkService service;&#10;    private Scanner scanner;&#10;&#10;    /**&#10;     * Create a ConsoleUI bound to the provided {@link NetworkService}.&#10;     *&#10;     * @param service service layer used to perform operations&#10;     */&#10;    public ConsoleUI(NetworkService service) {&#10;        this.service = service;&#10;        this.scanner = new Scanner(System.in);&#10;    }&#10;&#10;    /**&#10;     * Run the interactive console loop. This method blocks and reads user input&#10;     * from standard input until the user chooses to exit.&#10;     */&#10;    public void run() {&#10;        addTestData();&#10;        while (true) {&#10;            printMenu();&#10;            System.out.print(&quot;&gt; &quot;);&#10;            String choice = scanner.nextLine();&#10;            try {&#10;                switch (choice) {&#10;                    case &quot;1&quot;:&#10;                        addUser();&#10;                        break;&#10;                    case &quot;2&quot;:&#10;                        removeUser();&#10;                        break;&#10;                    case &quot;3&quot;:&#10;                        addFriend();&#10;                        break;&#10;                    case &quot;4&quot;:&#10;                        removeFriend();&#10;                        break;&#10;                    case &quot;5&quot;:&#10;                        showAllUsers();&#10;                        break;&#10;                    case &quot;6&quot;:&#10;                        showCommunities();&#10;                        break;&#10;                    case &quot;7&quot;:&#10;                        showMostSocial();&#10;                        break;&#10;                    case &quot;8&quot;:&#10;                        createCard();&#10;                        break;&#10;                    case &quot;9&quot;:&#10;                        listCards();&#10;                        break;&#10;                    case &quot;10&quot;:&#10;                        addDuckToCard();&#10;                        break;&#10;                    case &quot;11&quot;:&#10;                        removeDuckFromCard();&#10;                        break;&#10;                    case &quot;12&quot;:&#10;                        showCardPerformance();&#10;                        break;&#10;                    case &quot;13&quot;:&#10;                        createRaceEvent();&#10;                        break;&#10;                    case &quot;14&quot;:&#10;                        subscribeToEvent();&#10;                        break;&#10;                    case &quot;15&quot;:&#10;                        runRaceEvent();&#10;                        break;&#10;                    case &quot;16&quot;:&#10;                        showEventNotifications();&#10;                        break;&#10;                    case &quot;17&quot;:&#10;                        showUserNotifications();&#10;                        break;&#10;                    case &quot;0&quot;:&#10;                        System.out.println(&quot;Ieșire...&quot;);&#10;                        return;&#10;                    default:&#10;                        System.out.println(&quot;Opțiune invalidă!&quot;);&#10;                }&#10;            } catch (ValidationError | RepoError | NumberFormatException e) {&#10;                System.err.println(&quot;Eroare de service: &quot; + e.getMessage());&#10;            } catch (DateTimeException e) {&#10;                System.err.println(&quot;Eroare de format data: &quot; + e.getMessage());&#10;            } catch (IllegalArgumentException e) {&#10;                System.err.println(&quot;Eroare de argument: &quot; + e.getMessage());&#10;            } catch (Exception e) {&#10;                System.err.println(&quot;Eroare neașteptată: &quot; + e.getMessage());&#10;                e.printStackTrace();&#10;            }&#10;            System.out.println(&quot;---&quot;);&#10;        }&#10;    }&#10;&#10;    private void printMenu() {&#10;        System.out.println(&quot;1. Adaugă utilizator&quot;);&#10;        System.out.println(&quot;2. Șterge utilizator&quot;);&#10;        System.out.println(&quot;3. Adaugă prietenie&quot;);&#10;        System.out.println(&quot;4. Șterge prietenie&quot;);&#10;        System.out.println(&quot;5. Afișează toți utilizatorii&quot;);&#10;        System.out.println(&quot;6. Afișează numărul de comunități&quot;);&#10;        System.out.println(&quot;7. Afișează cea mai sociabilă comunitate&quot;);&#10;        System.out.println(&quot;8. Creează card (flock) de rațe&quot;);&#10;        System.out.println(&quot;9. Listează cardurile&quot;);&#10;        System.out.println(&quot;10. Adaugă rață în card&quot;);&#10;        System.out.println(&quot;11. Elimină rață din card&quot;);&#10;        System.out.println(&quot;12. Afișează performanța medie a cardului&quot;);&#10;        System.out.println(&quot;13. Creează RaceEvent&quot;);&#10;        System.out.println(&quot;14. Abonare utilizator la un eveniment&quot;);&#10;        System.out.println(&quot;15. Rulează RaceEvent și afișează rezultate&quot;);&#10;        System.out.println(&quot;16. Vezi notificări eveniment&quot;);&#10;        System.out.println(&quot;17. Vezi notificările unui utilizator&quot;);&#10;        System.out.println(&quot;0. Ieșire&quot;);&#10;    }&#10;&#10;    private void addUser() {&#10;        System.out.print(&quot;Tip (persoana/swimduck/flyduck/amphduck): &quot;);&#10;        String type = scanner.nextLine();&#10;        System.out.print(&quot;Username: &quot;);&#10;        String username = scanner.nextLine();&#10;        System.out.print(&quot;Email: &quot;);&#10;        String email = scanner.nextLine();&#10;        System.out.print(&quot;Password (min 8 characters): &quot;);&#10;        String password = scanner.nextLine();&#10;&#10;        User user;&#10;        List&lt;String&gt; duckTypes = Arrays.asList(&quot;swimduck&quot;, &quot;flyduck&quot;, &quot;amphduck&quot;);&#10;        if (type.equalsIgnoreCase(&quot;persoana&quot;)) {&#10;            System.out.print(&quot;Nume: &quot;);&#10;            String nume = scanner.nextLine();&#10;            System.out.print(&quot;Prenume: &quot;);&#10;            String prenume = scanner.nextLine();&#10;            System.out.print(&quot;Ocupatie: &quot;);&#10;            String ocupatie = scanner.nextLine();&#10;            System.out.print(&quot;Data nasterii (YYYY-MM-DD): &quot;);&#10;            LocalDate dataNasterii = LocalDate.parse(scanner.nextLine(), DateTimeFormatter.ISO_LOCAL_DATE);&#10;            System.out.print(&quot;Nivel empatie (1-10): &quot;);&#10;            int nivelEmpatie = Integer.parseInt(scanner.nextLine());&#10;            user = new Persoana(username, email, password, nume, prenume, ocupatie, dataNasterii, nivelEmpatie);&#10;        } else if (duckTypes.contains(type.toLowerCase())) {&#10;            System.out.print(&quot;Viteza (double): &quot;);&#10;            double viteza = Double.parseDouble(scanner.nextLine());&#10;            System.out.print(&quot;Rezistenta (double): &quot;);&#10;            double rezistenta = Double.parseDouble(scanner.nextLine());&#10;            switch (type.toLowerCase()) {&#10;                case &quot;swimduck&quot;:&#10;                    user = new SwimmingDuck(username, email, password, viteza, rezistenta);&#10;                    break;&#10;                case &quot;flyduck&quot;:&#10;                    user = new FlyingDuck(username, email, password, viteza, rezistenta);&#10;                    break;&#10;                case &quot;amphduck&quot;:&#10;                    user = new AmphibiousDuck(username, email, password, viteza, rezistenta);&#10;                    break;&#10;                default:&#10;                    System.out.println(&quot;Tip necunoscut!&quot;);&#10;                    return;&#10;            }&#10;        } else {&#10;            System.out.println(&quot;Tip necunoscut!&quot;);&#10;            return;&#10;        }&#10;        service.addUser(user);&#10;        System.out.println(&quot;Utilizator adăugat cu succes.&quot;);&#10;    }&#10;&#10;    private void removeUser() {&#10;        System.out.print(&quot;ID-ul utilizatorului de șters: &quot;);&#10;        int id = Integer.parseInt(scanner.nextLine());&#10;        User removed = service.removeUser(id);&#10;        System.out.println(&quot;Utilizatorul &quot; + removed.getUsername() + &quot; a fost șters cu succes.&quot;);&#10;    }&#10;&#10;    private void addFriend() {&#10;        System.out.print(&quot;ID-ul primului utilizator: &quot;);&#10;        int id1 = Integer.parseInt(scanner.nextLine());&#10;        System.out.print(&quot;ID-ul celui de-al doilea utilizator: &quot;);&#10;        int id2 = Integer.parseInt(scanner.nextLine());&#10;        service.addFriendship(id1, id2);&#10;        System.out.println(&quot;Prietenie adăugată cu succes între utilizatorii &quot; + id1 + &quot; și &quot; + id2 + &quot;.&quot;);&#10;    }&#10;&#10;    private void removeFriend() {&#10;        System.out.print(&quot;ID-ul primului utilizator: &quot;);&#10;        int id1 = Integer.parseInt(scanner.nextLine());&#10;        System.out.print(&quot;ID-ul celui de-al doilea utilizator: &quot;);&#10;        int id2 = Integer.parseInt(scanner.nextLine());&#10;        service.removeFriendship(id1, id2);&#10;        System.out.println(&quot;Prietenia dintre utilizatorii &quot; + id1 + &quot; și &quot; + id2 + &quot; a fost ștearsă cu succes.&quot;);&#10;    }&#10;&#10;    private void showAllUsers() {&#10;        System.out.println(&quot;Utilizatorii retelei:&quot;);&#10;        for (User u : service.getAllUsers()) {&#10;            System.out.println(u.getId() + &quot;: &quot; + u.getUsername() + &quot; &quot; + u.getFriends());&#10;        }&#10;    }&#10;&#10;    private void showCommunities() {&#10;        System.out.println(&quot;Numarul de comunitati (componente conexe): &quot; + service.getNumberOfCommunities());&#10;    }&#10;&#10;    private void showMostSocial() {&#10;        System.out.println(&quot;Cea mai sociabila comunitate este:&quot;);&#10;        List&lt;User&gt; community = service.getMostSocialCommunity();&#10;        for (User u : community) {&#10;            System.out.println(&quot; - &quot; + u.getUsername());&#10;        }&#10;    }&#10;&#10;    // CARD UI&#10;    private void createCard() {&#10;        System.out.print(&quot;Nume card: &quot;);&#10;        String nume = scanner.nextLine();&#10;        Card c = service.createCard(nume);&#10;        System.out.println(&quot;Card creat: &quot; + c.getId() + &quot; - &quot; + c.getNumeCard());&#10;    }&#10;&#10;    private void listCards() {&#10;        System.out.println(&quot;Carduri:&quot;);&#10;        for (Card c : service.getAllCards()) {&#10;            System.out.println(c.getId() + &quot;: &quot; + c.getNumeCard() + &quot; membri=&quot; + c.getMembri().size() + &quot; perfMedie=&quot; + String.format(&quot;%.2f&quot;, c.getPerformantaMedie()));&#10;        }&#10;    }&#10;&#10;    private void addDuckToCard() {&#10;        System.out.print(&quot;ID card: &quot;);&#10;        int cardId = Integer.parseInt(scanner.nextLine());&#10;        System.out.print(&quot;ID duck: &quot;);&#10;        int duckId = Integer.parseInt(scanner.nextLine());&#10;        service.addDuckToCard(cardId, duckId);&#10;        System.out.println(&quot;Rață adăugată în card.&quot;);&#10;    }&#10;&#10;    private void removeDuckFromCard() {&#10;        System.out.print(&quot;ID card: &quot;);&#10;        int cardId = Integer.parseInt(scanner.nextLine());&#10;        System.out.print(&quot;ID duck: &quot;);&#10;        int duckId = Integer.parseInt(scanner.nextLine());&#10;        service.removeDuckFromCard(cardId, duckId);&#10;        System.out.println(&quot;Rață eliminată din card.&quot;);&#10;    }&#10;&#10;    private void showCardPerformance() {&#10;        System.out.print(&quot;ID card: &quot;);&#10;        int cardId = Integer.parseInt(scanner.nextLine());&#10;        double perf = service.getCardPerformantaMedie(cardId);&#10;        System.out.println(&quot;Performanță medie card: &quot; + String.format(&quot;%.3f&quot;, perf));&#10;    }&#10;&#10;    // EVENT UI&#10;    private void createRaceEvent() {&#10;        System.out.print(&quot;Nume cursă: &quot;);&#10;        String name = scanner.nextLine();&#10;        System.out.print(&quot;Număr de linii (M): &quot;);&#10;        int lanes = Integer.parseInt(scanner.nextLine());&#10;        RaceEvent ev = service.createRaceEvent(name, lanes);&#10;        System.out.println(&quot;RaceEvent creat: &quot; + name + &quot; (#&quot; + ev.getId() + &quot;) cu &quot; + lanes + &quot; linii.&quot;);&#10;    }&#10;&#10;    private void subscribeToEvent() {&#10;        System.out.print(&quot;ID eveniment: &quot;);&#10;        int eventId = Integer.parseInt(scanner.nextLine());&#10;        System.out.print(&quot;ID utilizator pentru abonare: &quot;);&#10;        int userId = Integer.parseInt(scanner.nextLine());&#10;        service.subscribeToEvent(eventId, userId);&#10;        System.out.println(&quot;Utilizator abonat.&quot;);&#10;    }&#10;&#10;    /**&#10;     * Prompt for an event id, display the number of lanes (M), optionally accept&#10;     * user-provided per-lane distances and run the race, printing the results.&#10;     */&#10;    private void runRaceEvent() {&#10;        System.out.print(&quot;ID eveniment (RaceEvent): &quot;);&#10;        int eventId = Integer.parseInt(scanner.nextLine());&#10;        // Show lane count to help the user provide correct distances&#10;        int lanes = -1;&#10;        for (Event e : service.getAllEvents()) {&#10;            if (e.getId() == eventId &amp;&amp; e instanceof RaceEvent) {&#10;                lanes = ((RaceEvent) e).getLanes();&#10;                break;&#10;            }&#10;        }&#10;        if (lanes &gt; 0) {&#10;            System.out.println(&quot;Evenimentul are &quot; + lanes + &quot; linii (M).&quot;);&#10;        }&#10;        System.out.print(&quot;Introduceți distanțele pe linii (M valori separate prin spațiu, ex: 1 2 3). Lăsați gol pentru implicit: &quot;);&#10;        String line = scanner.nextLine().trim();&#10;        if (!line.isEmpty()) {&#10;            double[] distances = Arrays.stream(line.split(&quot;\\s+&quot;)).mapToDouble(Double::parseDouble).toArray();&#10;            service.setRaceDistances(eventId, distances);&#10;        }&#10;        List&lt;String&gt; results = service.runRace(eventId);&#10;        System.out.println(&quot;Rezultatele cursei:&quot;);&#10;        for (String r : results) {&#10;            System.out.println(r);&#10;        }&#10;    }&#10;&#10;    private void showEventNotifications() {&#10;        System.out.print(&quot;ID eveniment: &quot;);&#10;        int eventId = Integer.parseInt(scanner.nextLine());&#10;        for (domain.Event e : service.getAllEvents()) {&#10;            if (e.getId() == eventId) {&#10;                System.out.println(&quot;Notificări pentru eveniment &quot; + e.getName() + &quot;:&quot;);&#10;                for (String n : e.getNotificationLog()) System.out.println(&quot; - &quot; + n);&#10;                return;&#10;            }&#10;        }&#10;        System.out.println(&quot;Eveniment inexistent.&quot;);&#10;    }&#10;&#10;    /**&#10;     * Display the notifications stored on a user (Observer inbox).&#10;     */&#10;    private void showUserNotifications() {&#10;        System.out.print(&quot;ID utilizator: &quot;);&#10;        int userId = Integer.parseInt(scanner.nextLine());&#10;        List&lt;String&gt; notes = service.getUserNotifications(userId);&#10;        if (notes.isEmpty()) {&#10;            System.out.println(&quot;(fără notificări)&quot;);&#10;        } else {&#10;            System.out.println(&quot;Notificări pentru utilizatorul #&quot; + userId + &quot;:&quot;);&#10;            for (String n : notes) {&#10;                System.out.println(&quot; - &quot; + n);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Seed the application with a mix of persons and ducks, including enough swimmers&#10;     * (SwimmingDuck and AmphibiousDuck) to make race events runnable out-of-the-box.&#10;     * Also creates two race events: one auto-run at startup for demo purposes and one&#10;     * left for interaction via the menu.&#10;     */&#10;    private void addTestData() {&#10;        try {&#10;            // Comunitatea 1 (linie)&#10;            service.addUser(new Persoana(1, &quot;ana&quot;, &quot;a@g.com&quot;, &quot;pass1231&quot;, &quot;Ana&quot;, &quot;Pop&quot;, &quot;Student&quot;, LocalDate.of(2000, 5, 15), 8));&#10;            service.addUser(new Persoana(2, &quot;bogdan&quot;, &quot;b@g.com&quot;, &quot;pass4561&quot;, &quot;Bogdan&quot;, &quot;Ion&quot;, &quot;Inginer&quot;, LocalDate.of(1995, 10, 20), 5));&#10;            service.addUser(new Persoana(3, &quot;cipi&quot;, &quot;c@g.com&quot;, &quot;pass7891&quot;, &quot;Cipi&quot;, &quot;Vlad&quot;, &quot;Artist&quot;, LocalDate.of(1998, 2, 1), 9));&#10;            service.addFriendship(1, 2);&#10;            service.addFriendship(2, 3);&#10;&#10;            // Comunitatea 2 (triunghi) + more ducks&#10;            service.addUser(new SwimmingDuck(4, &quot;donald&quot;, &quot;d1@g.com&quot;, &quot;quack111&quot;, 15.5, 20.0));&#10;            service.addUser(new FlyingDuck(5, &quot;daffy&quot;, &quot;d2@g.com&quot;, &quot;quack111&quot;, 50.0, 10.5));&#10;            service.addUser(new Persoana(6, &quot;elena&quot;, &quot;e@g.com&quot;, &quot;pass1011&quot;, &quot;Elena&quot;, &quot;Turc&quot;, &quot;Medic&quot;, LocalDate.of(1990, 7, 30), 7));&#10;            service.addFriendship(4, 5);&#10;            service.addFriendship(5, 6);&#10;            service.addFriendship(4, 6);&#10;&#10;            // Comunitatea 3 (un singur nod)&#10;            service.addUser(new Persoana(7, &quot;singur&quot;, &quot;s@g.com&quot;, &quot;passSolitar&quot;, &quot;Singur&quot;, &quot;Singurel&quot;, &quot;Gardian&quot;, LocalDate.of(1985, 1, 1), 3));&#10;&#10;            // Extra ducks for richer race/card scenarios (ensure enough swimmers)&#10;            service.addUser(new SwimmingDuck(8, &quot;splash&quot;, &quot;sp@g.com&quot;, &quot;swimPass1&quot;, 18.0, 19.0));&#10;            service.addUser(new AmphibiousDuck(9, &quot;amphi&quot;, &quot;am@g.com&quot;, &quot;amphPass1&quot;, 22.0, 25.0));&#10;            service.addUser(new FlyingDuck(10, &quot;swift&quot;, &quot;sw@g.com&quot;, &quot;flyPass11&quot;, 60.0, 11.0));&#10;            service.addUser(new SwimmingDuck(11, &quot;wave&quot;, &quot;wa@g.com&quot;, &quot;swimPass2&quot;, 14.0, 30.0));&#10;            service.addUser(new AmphibiousDuck(12, &quot;combo&quot;, &quot;co@g.com&quot;, &quot;amphPass2&quot;, 26.0, 18.0));&#10;            // Additional swimmers to guarantee enough eligible participants&#10;            service.addUser(new SwimmingDuck(13, &quot;marina&quot;, &quot;m1@g.com&quot;, &quot;swimPass3&quot;, 16.5, 21.0));&#10;            service.addUser(new SwimmingDuck(14, &quot;delta&quot;, &quot;dlt@g.com&quot;, &quot;swimPass4&quot;, 19.2, 17.5));&#10;            service.addUser(new AmphibiousDuck(15, &quot;hybrid&quot;, &quot;hy@g.com&quot;, &quot;amphPass3&quot;, 24.0, 23.0));&#10;&#10;            // Create cards using auto-generated ids&#10;            Card swimMasters = service.createCard(&quot;SwimMasters&quot;);&#10;            Card skyFlyers = service.createCard(&quot;SkyFlyers&quot;);&#10;            Card hybridElite = service.createCard(&quot;HybridElite&quot;);&#10;&#10;            // Populate cards with ducks (using actual ids)&#10;            service.addDuckToCard(swimMasters.getId(), 4);  // donald (SWIMMING)&#10;            service.addDuckToCard(swimMasters.getId(), 8);  // splash (SWIMMING)&#10;            service.addDuckToCard(swimMasters.getId(), 11); // wave (SWIMMING)&#10;&#10;            service.addDuckToCard(skyFlyers.getId(), 5);  // daffy (FLYING)&#10;            service.addDuckToCard(skyFlyers.getId(), 10); // swift (FLYING)&#10;&#10;            service.addDuckToCard(hybridElite.getId(), 9);  // amphi (FLYING_AND_SWIMMING)&#10;            service.addDuckToCard(hybridElite.getId(), 12); // combo (FLYING_AND_SWIMMING)&#10;&#10;            // Create race event and subscribe users&#10;            RaceEvent race1 = service.createRaceEvent(&quot;Spring Splash&quot;, 3);&#10;            service.subscribeToEvent(race1.getId(), 1);  // Ana (person)&#10;            service.subscribeToEvent(race1.getId(), 4);  // donald (duck)&#10;            service.subscribeToEvent(race1.getId(), 9);  // amphi (duck)&#10;&#10;            // Set distances and run race&#10;            service.setRaceDistances(race1.getId(), new double[]{1.0, 1.2, 0.8});&#10;            service.runRace(race1.getId());&#10;&#10;            // Second race event&#10;            RaceEvent race2 = service.createRaceEvent(&quot;Championship Finals&quot;, 4);&#10;            service.subscribeToEvent(race2.getId(), 2);  // Bogdan (person)&#10;            service.subscribeToEvent(race2.getId(), 8);  // splash (duck)&#10;            service.subscribeToEvent(race2.getId(), 12); // combo (duck)&#10;&#10;            // Set default distances&#10;            service.setRaceDistances(race2.getId(), new double[]{1.0, 1.0, 1.0, 1.0});&#10;&#10;&#10;            System.out.println(&quot;RaceEvent 200 a fost rulat cu distanțe predefinite; verifică notificările cu opțiunea 16 sau rulează alt eveniment cu opțiunea 15.&quot;);&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;Eroare la încărcarea datelor de test: &quot; + e.getMessage());&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package UI;&#10;&#10;import domain.*;&#10;import errors.RepoError;&#10;import errors.ValidationError;&#10;import service.NetworkService;&#10;&#10;import java.time.DateTimeException;&#10;import java.time.LocalDate;&#10;import java.time.format.DateTimeFormatter;&#10;import java.util.Arrays;&#10;import java.util.List;&#10;import java.util.Scanner;&#10;&#10;/**&#10; * Simple console-based user interface for interacting with the NetworkService.&#10; * Provides commands to add/remove users, manage friendships and display&#10; * network-related information.&#10; */&#10;public class ConsoleUI {&#10;    private NetworkService service;&#10;    private Scanner scanner;&#10;&#10;    /**&#10;     * Create a ConsoleUI bound to the provided {@link NetworkService}.&#10;     *&#10;     * @param service service layer used to perform operations&#10;     */&#10;    public ConsoleUI(NetworkService service) {&#10;        this.service = service;&#10;        this.scanner = new Scanner(System.in);&#10;    }&#10;&#10;    /**&#10;     * Run the interactive console loop. This method blocks and reads user input&#10;     * from standard input until the user chooses to exit.&#10;     */&#10;    public void run() {&#10;        addTestData();&#10;        while (true) {&#10;            printMenu();&#10;            System.out.print(&quot;&gt; &quot;);&#10;            String choice = scanner.nextLine();&#10;            try {&#10;                switch (choice) {&#10;                    case &quot;1&quot;:&#10;                        addUser();&#10;                        break;&#10;                    case &quot;2&quot;:&#10;                        removeUser();&#10;                        break;&#10;                    case &quot;3&quot;:&#10;                        addFriend();&#10;                        break;&#10;                    case &quot;4&quot;:&#10;                        removeFriend();&#10;                        break;&#10;                    case &quot;5&quot;:&#10;                        showAllUsers();&#10;                        break;&#10;                    case &quot;6&quot;:&#10;                        showCommunities();&#10;                        break;&#10;                    case &quot;7&quot;:&#10;                        showMostSocial();&#10;                        break;&#10;                    case &quot;8&quot;:&#10;                        createCard();&#10;                        break;&#10;                    case &quot;9&quot;:&#10;                        listCards();&#10;                        break;&#10;                    case &quot;10&quot;:&#10;                        addDuckToCard();&#10;                        break;&#10;                    case &quot;11&quot;:&#10;                        removeDuckFromCard();&#10;                        break;&#10;                    case &quot;12&quot;:&#10;                        showCardPerformance();&#10;                        break;&#10;                    case &quot;13&quot;:&#10;                        createRaceEvent();&#10;                        break;&#10;                    case &quot;14&quot;:&#10;                        subscribeToEvent();&#10;                        break;&#10;                    case &quot;15&quot;:&#10;                        runRaceEvent();&#10;                        break;&#10;                    case &quot;16&quot;:&#10;                        showEventNotifications();&#10;                        break;&#10;                    case &quot;17&quot;:&#10;                        showUserNotifications();&#10;                        break;&#10;                    case &quot;0&quot;:&#10;                        System.out.println(&quot;Ieșire...&quot;);&#10;                        return;&#10;                    default:&#10;                        System.out.println(&quot;Opțiune invalidă!&quot;);&#10;                }&#10;            } catch (ValidationError | RepoError | NumberFormatException e) {&#10;                System.err.println(&quot;Eroare de service: &quot; + e.getMessage());&#10;            } catch (DateTimeException e) {&#10;                System.err.println(&quot;Eroare de format data: &quot; + e.getMessage());&#10;            } catch (IllegalArgumentException e) {&#10;                System.err.println(&quot;Eroare de argument: &quot; + e.getMessage());&#10;            } catch (Exception e) {&#10;                System.err.println(&quot;Eroare neașteptată: &quot; + e.getMessage());&#10;                e.printStackTrace();&#10;            }&#10;            System.out.println(&quot;---&quot;);&#10;        }&#10;    }&#10;&#10;    private void printMenu() {&#10;        System.out.println(&quot;1. Adaugă utilizator&quot;);&#10;        System.out.println(&quot;2. Șterge utilizator&quot;);&#10;        System.out.println(&quot;3. Adaugă prietenie&quot;);&#10;        System.out.println(&quot;4. Șterge prietenie&quot;);&#10;        System.out.println(&quot;5. Afișează toți utilizatorii&quot;);&#10;        System.out.println(&quot;6. Afișează numărul de comunități&quot;);&#10;        System.out.println(&quot;7. Afișează cea mai sociabilă comunitate&quot;);&#10;        System.out.println(&quot;8. Creează card (flock) de rațe&quot;);&#10;        System.out.println(&quot;9. Listează cardurile&quot;);&#10;        System.out.println(&quot;10. Adaugă rață în card&quot;);&#10;        System.out.println(&quot;11. Elimină rață din card&quot;);&#10;        System.out.println(&quot;12. Afișează performanța medie a cardului&quot;);&#10;        System.out.println(&quot;13. Creează RaceEvent&quot;);&#10;        System.out.println(&quot;14. Abonare utilizator la un eveniment&quot;);&#10;        System.out.println(&quot;15. Rulează RaceEvent și afișează rezultate&quot;);&#10;        System.out.println(&quot;16. Vezi notificări eveniment&quot;);&#10;        System.out.println(&quot;17. Vezi notificările unui utilizator&quot;);&#10;        System.out.println(&quot;0. Ieșire&quot;);&#10;    }&#10;&#10;    private void addUser() {&#10;        System.out.print(&quot;Tip (persoana/swimduck/flyduck/amphduck): &quot;);&#10;        String type = scanner.nextLine();&#10;        System.out.print(&quot;Username: &quot;);&#10;        String username = scanner.nextLine();&#10;        System.out.print(&quot;Email: &quot;);&#10;        String email = scanner.nextLine();&#10;        System.out.print(&quot;Password (min 8 characters): &quot;);&#10;        String password = scanner.nextLine();&#10;&#10;        User user;&#10;        List&lt;String&gt; duckTypes = Arrays.asList(&quot;swimduck&quot;, &quot;flyduck&quot;, &quot;amphduck&quot;);&#10;        if (type.equalsIgnoreCase(&quot;persoana&quot;)) {&#10;            System.out.print(&quot;Nume: &quot;);&#10;            String nume = scanner.nextLine();&#10;            System.out.print(&quot;Prenume: &quot;);&#10;            String prenume = scanner.nextLine();&#10;            System.out.print(&quot;Ocupatie: &quot;);&#10;            String ocupatie = scanner.nextLine();&#10;            System.out.print(&quot;Data nasterii (YYYY-MM-DD): &quot;);&#10;            LocalDate dataNasterii = LocalDate.parse(scanner.nextLine(), DateTimeFormatter.ISO_LOCAL_DATE);&#10;            System.out.print(&quot;Nivel empatie (1-10): &quot;);&#10;            int nivelEmpatie = Integer.parseInt(scanner.nextLine());&#10;            user = new Persoana(username, email, password, nume, prenume, ocupatie, dataNasterii, nivelEmpatie);&#10;        } else if (duckTypes.contains(type.toLowerCase())) {&#10;            System.out.print(&quot;Viteza (double): &quot;);&#10;            double viteza = Double.parseDouble(scanner.nextLine());&#10;            System.out.print(&quot;Rezistenta (double): &quot;);&#10;            double rezistenta = Double.parseDouble(scanner.nextLine());&#10;            switch (type.toLowerCase()) {&#10;                case &quot;swimduck&quot;:&#10;                    user = new SwimmingDuck(username, email, password, viteza, rezistenta);&#10;                    break;&#10;                case &quot;flyduck&quot;:&#10;                    user = new FlyingDuck(username, email, password, viteza, rezistenta);&#10;                    break;&#10;                case &quot;amphduck&quot;:&#10;                    user = new AmphibiousDuck(username, email, password, viteza, rezistenta);&#10;                    break;&#10;                default:&#10;                    System.out.println(&quot;Tip necunoscut!&quot;);&#10;                    return;&#10;            }&#10;        } else {&#10;            System.out.println(&quot;Tip necunoscut!&quot;);&#10;            return;&#10;        }&#10;        service.addUser(user);&#10;        System.out.println(&quot;Utilizator adăugat cu succes.&quot;);&#10;    }&#10;&#10;    private void removeUser() {&#10;        System.out.print(&quot;ID-ul utilizatorului de șters: &quot;);&#10;        int id = Integer.parseInt(scanner.nextLine());&#10;        User removed = service.removeUser(id);&#10;        System.out.println(&quot;Utilizatorul &quot; + removed.getUsername() + &quot; a fost șters cu succes.&quot;);&#10;    }&#10;&#10;    private void addFriend() {&#10;        System.out.print(&quot;ID-ul primului utilizator: &quot;);&#10;        int id1 = Integer.parseInt(scanner.nextLine());&#10;        System.out.print(&quot;ID-ul celui de-al doilea utilizator: &quot;);&#10;        int id2 = Integer.parseInt(scanner.nextLine());&#10;        service.addFriendship(id1, id2);&#10;        System.out.println(&quot;Prietenie adăugată cu succes între utilizatorii &quot; + id1 + &quot; și &quot; + id2 + &quot;.&quot;);&#10;    }&#10;&#10;    private void removeFriend() {&#10;        System.out.print(&quot;ID-ul primului utilizator: &quot;);&#10;        int id1 = Integer.parseInt(scanner.nextLine());&#10;        System.out.print(&quot;ID-ul celui de-al doilea utilizator: &quot;);&#10;        int id2 = Integer.parseInt(scanner.nextLine());&#10;        service.removeFriendship(id1, id2);&#10;        System.out.println(&quot;Prietenia dintre utilizatorii &quot; + id1 + &quot; și &quot; + id2 + &quot; a fost ștearsă cu succes.&quot;);&#10;    }&#10;&#10;    private void showAllUsers() {&#10;        System.out.println(&quot;Utilizatorii retelei:&quot;);&#10;        for (User u : service.getAllUsers()) {&#10;            System.out.println(u.getId() + &quot;: &quot; + u.getUsername() + &quot; &quot; + u.getFriends());&#10;        }&#10;    }&#10;&#10;    private void showCommunities() {&#10;        System.out.println(&quot;Numarul de comunitati (componente conexe): &quot; + service.getNumberOfCommunities());&#10;    }&#10;&#10;    private void showMostSocial() {&#10;        System.out.println(&quot;Cea mai sociabila comunitate este:&quot;);&#10;        List&lt;User&gt; community = service.getMostSocialCommunity();&#10;        for (User u : community) {&#10;            System.out.println(&quot; - &quot; + u.getUsername());&#10;        }&#10;    }&#10;&#10;    // CARD UI&#10;    private void createCard() {&#10;        System.out.print(&quot;Nume card: &quot;);&#10;        String nume = scanner.nextLine();&#10;        Card c = service.createCard(nume);&#10;        System.out.println(&quot;Card creat: &quot; + c.getId() + &quot; - &quot; + c.getNumeCard());&#10;    }&#10;&#10;    private void listCards() {&#10;        System.out.println(&quot;Carduri:&quot;);&#10;        for (Card c : service.getAllCards()) {&#10;            System.out.println(c.getId() + &quot;: &quot; + c.getNumeCard() + &quot; membri=&quot; + c.getMembri().size() + &quot; perfMedie=&quot; + String.format(&quot;%.2f&quot;, c.getPerformantaMedie()));&#10;        }&#10;    }&#10;&#10;    private void addDuckToCard() {&#10;        System.out.print(&quot;ID card: &quot;);&#10;        int cardId = Integer.parseInt(scanner.nextLine());&#10;        System.out.print(&quot;ID duck: &quot;);&#10;        int duckId = Integer.parseInt(scanner.nextLine());&#10;        service.addDuckToCard(cardId, duckId);&#10;        System.out.println(&quot;Rață adăugată în card.&quot;);&#10;    }&#10;&#10;    private void removeDuckFromCard() {&#10;        System.out.print(&quot;ID card: &quot;);&#10;        int cardId = Integer.parseInt(scanner.nextLine());&#10;        System.out.print(&quot;ID duck: &quot;);&#10;        int duckId = Integer.parseInt(scanner.nextLine());&#10;        service.removeDuckFromCard(cardId, duckId);&#10;        System.out.println(&quot;Rață eliminată din card.&quot;);&#10;    }&#10;&#10;    private void showCardPerformance() {&#10;        System.out.print(&quot;ID card: &quot;);&#10;        int cardId = Integer.parseInt(scanner.nextLine());&#10;        double perf = service.getCardPerformantaMedie(cardId);&#10;        System.out.println(&quot;Performanță medie card: &quot; + String.format(&quot;%.3f&quot;, perf));&#10;    }&#10;&#10;    // EVENT UI&#10;    private void createRaceEvent() {&#10;        System.out.print(&quot;Nume cursă: &quot;);&#10;        String name = scanner.nextLine();&#10;        System.out.print(&quot;Număr de linii (M): &quot;);&#10;        int lanes = Integer.parseInt(scanner.nextLine());&#10;        RaceEvent ev = service.createRaceEvent(name, lanes);&#10;        System.out.println(&quot;RaceEvent creat: &quot; + name + &quot; (#&quot; + ev.getId() + &quot;) cu &quot; + lanes + &quot; linii.&quot;);&#10;    }&#10;&#10;    private void subscribeToEvent() {&#10;        System.out.print(&quot;ID eveniment: &quot;);&#10;        int eventId = Integer.parseInt(scanner.nextLine());&#10;        System.out.print(&quot;ID utilizator pentru abonare: &quot;);&#10;        int userId = Integer.parseInt(scanner.nextLine());&#10;        service.subscribeToEvent(eventId, userId);&#10;        System.out.println(&quot;Utilizator abonat.&quot;);&#10;    }&#10;&#10;    /**&#10;     * Prompt for an event id, display the number of lanes (M), optionally accept&#10;     * user-provided per-lane distances and run the race, printing the results.&#10;     */&#10;    private void runRaceEvent() {&#10;        System.out.print(&quot;ID eveniment (RaceEvent): &quot;);&#10;        int eventId = Integer.parseInt(scanner.nextLine());&#10;        // Show lane count to help the user provide correct distances&#10;        int lanes = -1;&#10;        for (Event e : service.getAllEvents()) {&#10;            if (e.getId() == eventId &amp;&amp; e instanceof RaceEvent) {&#10;                lanes = ((RaceEvent) e).getLanes();&#10;                break;&#10;            }&#10;        }&#10;        if (lanes &gt; 0) {&#10;            System.out.println(&quot;Evenimentul are &quot; + lanes + &quot; linii (M).&quot;);&#10;        }&#10;        System.out.print(&quot;Introduceți distanțele pe linii (M valori separate prin spațiu, ex: 1 2 3). Lăsați gol pentru implicit: &quot;);&#10;        String line = scanner.nextLine().trim();&#10;        if (!line.isEmpty()) {&#10;            double[] distances = Arrays.stream(line.split(&quot;\\s+&quot;)).mapToDouble(Double::parseDouble).toArray();&#10;            service.setRaceDistances(eventId, distances);&#10;        }&#10;        List&lt;String&gt; results = service.runRace(eventId);&#10;        System.out.println(&quot;Rezultatele cursei:&quot;);&#10;        for (String r : results) {&#10;            System.out.println(r);&#10;        }&#10;    }&#10;&#10;    private void showEventNotifications() {&#10;        System.out.print(&quot;ID eveniment: &quot;);&#10;        int eventId = Integer.parseInt(scanner.nextLine());&#10;        for (domain.Event e : service.getAllEvents()) {&#10;            if (e.getId() == eventId) {&#10;                System.out.println(&quot;Notificări pentru eveniment &quot; + e.getName() + &quot;:&quot;);&#10;                for (String n : e.getNotificationLog()) System.out.println(&quot; - &quot; + n);&#10;                return;&#10;            }&#10;        }&#10;        System.out.println(&quot;Eveniment inexistent.&quot;);&#10;    }&#10;&#10;    /**&#10;     * Display the notifications stored on a user (Observer inbox).&#10;     */&#10;    private void showUserNotifications() {&#10;        System.out.print(&quot;ID utilizator: &quot;);&#10;        int userId = Integer.parseInt(scanner.nextLine());&#10;        List&lt;String&gt; notes = service.getUserNotifications(userId);&#10;        if (notes.isEmpty()) {&#10;            System.out.println(&quot;(fără notificări)&quot;);&#10;        } else {&#10;            System.out.println(&quot;Notificări pentru utilizatorul #&quot; + userId + &quot;:&quot;);&#10;            for (String n : notes) {&#10;                System.out.println(&quot; - &quot; + n);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Seed the application with a mix of persons and ducks, including enough swimmers&#10;     * (SwimmingDuck and AmphibiousDuck) to make race events runnable out-of-the-box.&#10;     * Also creates two race events: one auto-run at startup for demo purposes and one&#10;     * left for interaction via the menu.&#10;     */&#10;    private void addTestData() {&#10;        try {&#10;            // Comunitatea 1 (linie)&#10;            service.addUser(new Persoana(1, &quot;ana&quot;, &quot;a@g.com&quot;, &quot;pass1231&quot;, &quot;Ana&quot;, &quot;Pop&quot;, &quot;Student&quot;, LocalDate.of(2000, 5, 15), 8));&#10;            service.addUser(new Persoana(2, &quot;bogdan&quot;, &quot;b@g.com&quot;, &quot;pass4561&quot;, &quot;Bogdan&quot;, &quot;Ion&quot;, &quot;Inginer&quot;, LocalDate.of(1995, 10, 20), 5));&#10;            service.addUser(new Persoana(3, &quot;cipi&quot;, &quot;c@g.com&quot;, &quot;pass7891&quot;, &quot;Cipi&quot;, &quot;Vlad&quot;, &quot;Artist&quot;, LocalDate.of(1998, 2, 1), 9));&#10;            service.addFriendship(1, 2);&#10;            service.addFriendship(2, 3);&#10;&#10;            // Comunitatea 2 (triunghi) + more ducks&#10;            service.addUser(new SwimmingDuck(4, &quot;donald&quot;, &quot;d1@g.com&quot;, &quot;quack111&quot;, 15.5, 20.0));&#10;            service.addUser(new FlyingDuck(5, &quot;daffy&quot;, &quot;d2@g.com&quot;, &quot;quack111&quot;, 50.0, 10.5));&#10;            service.addUser(new Persoana(6, &quot;elena&quot;, &quot;e@g.com&quot;, &quot;pass1011&quot;, &quot;Elena&quot;, &quot;Turc&quot;, &quot;Medic&quot;, LocalDate.of(1990, 7, 30), 7));&#10;            service.addFriendship(4, 5);&#10;            service.addFriendship(5, 6);&#10;            service.addFriendship(4, 6);&#10;&#10;            // Comunitatea 3 (un singur nod)&#10;            service.addUser(new Persoana(7, &quot;singur&quot;, &quot;s@g.com&quot;, &quot;passSolitar&quot;, &quot;Singur&quot;, &quot;Singurel&quot;, &quot;Gardian&quot;, LocalDate.of(1985, 1, 1), 3));&#10;&#10;            // Extra ducks for richer race/card scenarios (ensure enough swimmers)&#10;            service.addUser(new SwimmingDuck(8, &quot;splash&quot;, &quot;sp@g.com&quot;, &quot;swimPass1&quot;, 18.0, 19.0));&#10;            service.addUser(new AmphibiousDuck(9, &quot;amphi&quot;, &quot;am@g.com&quot;, &quot;amphPass1&quot;, 22.0, 25.0));&#10;            service.addUser(new FlyingDuck(10, &quot;swift&quot;, &quot;sw@g.com&quot;, &quot;flyPass11&quot;, 60.0, 11.0));&#10;            service.addUser(new SwimmingDuck(11, &quot;wave&quot;, &quot;wa@g.com&quot;, &quot;swimPass2&quot;, 14.0, 30.0));&#10;            service.addUser(new AmphibiousDuck(12, &quot;combo&quot;, &quot;co@g.com&quot;, &quot;amphPass2&quot;, 26.0, 18.0));&#10;            // Additional swimmers to guarantee enough eligible participants&#10;            service.addUser(new SwimmingDuck(13, &quot;marina&quot;, &quot;m1@g.com&quot;, &quot;swimPass3&quot;, 16.5, 21.0));&#10;            service.addUser(new SwimmingDuck(14, &quot;delta&quot;, &quot;dlt@g.com&quot;, &quot;swimPass4&quot;, 19.2, 17.5));&#10;            service.addUser(new AmphibiousDuck(15, &quot;hybrid&quot;, &quot;hy@g.com&quot;, &quot;amphPass3&quot;, 24.0, 23.0));&#10;&#10;            // Create cards using auto-generated ids&#10;            Card swimMasters = service.createCard(&quot;SwimMasters&quot;);&#10;            Card skyFlyers = service.createCard(&quot;SkyFlyers&quot;);&#10;            Card hybridElite = service.createCard(&quot;HybridElite&quot;);&#10;&#10;            // Populate cards with ducks (using actual ids)&#10;            service.addDuckToCard(swimMasters.getId(), 4);  // donald (SWIMMING)&#10;            service.addDuckToCard(swimMasters.getId(), 8);  // splash (SWIMMING)&#10;            service.addDuckToCard(swimMasters.getId(), 11); // wave (SWIMMING)&#10;&#10;            service.addDuckToCard(skyFlyers.getId(), 5);  // daffy (FLYING)&#10;            service.addDuckToCard(skyFlyers.getId(), 10); // swift (FLYING)&#10;&#10;            service.addDuckToCard(hybridElite.getId(), 9);  // amphi (FLYING_AND_SWIMMING)&#10;            service.addDuckToCard(hybridElite.getId(), 12); // combo (FLYING_AND_SWIMMING)&#10;&#10;            // Create race event and subscribe users&#10;            RaceEvent race1 = service.createRaceEvent(&quot;Spring Splash&quot;, 3);&#10;            service.subscribeToEvent(race1.getId(), 1);  // Ana (person)&#10;            service.subscribeToEvent(race1.getId(), 4);  // donald (duck)&#10;            service.subscribeToEvent(race1.getId(), 9);  // amphi (duck)&#10;&#10;            // Set distances and run race&#10;            service.setRaceDistances(race1.getId(), new double[]{1.0, 1.2, 0.8});&#10;            service.runRace(race1.getId());&#10;&#10;            // Second race event&#10;            RaceEvent race2 = service.createRaceEvent(&quot;Championship Finals&quot;, 4);&#10;            service.subscribeToEvent(race2.getId(), 2);  // Bogdan (person)&#10;            service.subscribeToEvent(race2.getId(), 8);  // splash (duck)&#10;            service.subscribeToEvent(race2.getId(), 12); // combo (duck)&#10;&#10;            // Set default distances&#10;            service.setRaceDistances(race2.getId(), new double[]{1.0, 1.0, 1.0, 1.0});&#10;&#10;&#10;            System.out.println(&quot;RaceEvent 200 a fost rulat cu distanțe predefinite; verifică notificările cu opțiunea 16 sau rulează alt eveniment cu opțiunea 15.&quot;);&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;Eroare la încărcarea datelor de test: &quot; + e.getMessage());&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/domain/Event.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/domain/Event.java" />
              <option name="originalContent" value="package domain;&#10;&#10;import java.util.ArrayList;&#10;import java.util.Collections;&#10;import java.util.List;&#10;&#10;/**&#10; * General event in the network (Observable). Users can subscribe/unsubscribe&#10; * and the event can notify them (simple console notification). Each event keeps&#10; * a list of subscribers and a notification log with all messages that were sent.&#10; */&#10;public class Event {&#10;    private final int id;&#10;    private final String name;&#10;    private final List&lt;User&gt; subscribers = new ArrayList&lt;&gt;();&#10;    private final List&lt;String&gt; notificationLog = new ArrayList&lt;&gt;();&#10;&#10;    /**&#10;     * Construct a new event with id and name.&#10;     *&#10;     * @param id    event identifier&#10;     * @param name  non-empty display name&#10;     * @throws IllegalArgumentException if name is null or empty&#10;     */&#10;    public Event(int id, String name) {&#10;        if(name == null || name.isEmpty()) throw new IllegalArgumentException(&quot;Event name must not be empty&quot;);&#10;        this.id = id;&#10;        this.name = name;&#10;    }&#10;&#10;    /**&#10;     * @return the unique id of this event&#10;     */&#10;    public int getId() { return id; }&#10;&#10;    /**&#10;     * @return the display name of this event&#10;     */&#10;    public String getName() { return name; }&#10;&#10;    /**&#10;     * @return an unmodifiable view of the current subscribers&#10;     */&#10;    public List&lt;User&gt; getSubscribers() { return Collections.unmodifiableList(subscribers); }&#10;&#10;    /**&#10;     * @return an unmodifiable view of the notification messages sent by this event&#10;     */&#10;    public List&lt;String&gt; getNotificationLog() { return Collections.unmodifiableList(notificationLog); }&#10;&#10;    /**&#10;     * Internal helper for persistence layers to inject subscribers during hydration.&#10;     */&#10;    public void attachSubscriber(User user) {&#10;        if(user != null &amp;&amp; !subscribers.contains(user)) {&#10;            subscribers.add(user);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Internal helper for persistence layers to rehydrate historical notifications.&#10;     */&#10;    public void appendNotification(String message) {&#10;        if(message != null) notificationLog.add(message);&#10;    }&#10;&#10;    /**&#10;     * Subscribe a user to receive notifications from this event. Duplicates are ignored.&#10;     *&#10;     * @param user non-null user to subscribe&#10;     */&#10;    public void subscribe(User user) {&#10;        if(user != null &amp;&amp; !subscribers.contains(user)) {&#10;            subscribers.add(user);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Unsubscribe a user from this event.&#10;     *&#10;     * @param user user to remove (no-op if not subscribed)&#10;     */&#10;    public void unsubscribe(User user) {&#10;        subscribers.remove(user);&#10;    }&#10;&#10;    /**&#10;     * Notify all subscribers with a message and append it to the local notification log.&#10;     * Implemented as simple console output per subscriber for demo purposes.&#10;     *&#10;     * @param message message to broadcast&#10;     */&#10;    protected void notifySubscribers(String message) {&#10;        String full = &quot;[Event &quot; + id + &quot;:&quot; + name + &quot;] &quot; + message;&#10;        notificationLog.add(full);&#10;        for (User u : subscribers) {&#10;            // push notification into user's inbox&#10;            u.receiveNotification(full);&#10;            System.out.println(&quot;[Notify &quot; + u.getUsername() + &quot;] &quot; + full);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package domain;&#10;&#10;import java.util.ArrayList;&#10;import java.util.Collections;&#10;import java.util.List;&#10;&#10;/**&#10; * General event in the network (Observable). Users can subscribe/unsubscribe&#10; * and the event can notify them (simple console notification). Each event keeps&#10; * a list of subscribers and a notification log with all messages that were sent.&#10; */&#10;public class Event {&#10;    private final int id;&#10;    private final String name;&#10;    private final List&lt;User&gt; subscribers = new ArrayList&lt;&gt;();&#10;    private final List&lt;String&gt; notificationLog = new ArrayList&lt;&gt;();&#10;&#10;    /**&#10;     * Construct a new event with id and name.&#10;     *&#10;     * @param id    event identifier&#10;     * @param name  non-empty display name&#10;     * @throws IllegalArgumentException if name is null or empty&#10;     */&#10;    public Event(int id, String name) {&#10;        if(name == null || name.isEmpty()) throw new IllegalArgumentException(&quot;Event name must not be empty&quot;);&#10;        this.id = id;&#10;        this.name = name;&#10;    }&#10;&#10;    /**&#10;     * @return the unique id of this event&#10;     */&#10;    public int getId() { return id; }&#10;&#10;    /**&#10;     * @return the display name of this event&#10;     */&#10;    public String getName() { return name; }&#10;&#10;    /**&#10;     * @return an unmodifiable view of the current subscribers&#10;     */&#10;    public List&lt;User&gt; getSubscribers() { return Collections.unmodifiableList(subscribers); }&#10;&#10;    /**&#10;     * @return an unmodifiable view of the notification messages sent by this event&#10;     */&#10;    public List&lt;String&gt; getNotificationLog() { return Collections.unmodifiableList(notificationLog); }&#10;&#10;    /**&#10;     * Internal helper for persistence layers to inject subscribers during hydration.&#10;     */&#10;    public void attachSubscriber(User user) {&#10;        if(user != null &amp;&amp; !subscribers.contains(user)) {&#10;            subscribers.add(user);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Internal helper for persistence layers to rehydrate historical notifications.&#10;     */&#10;    public void appendNotification(String message) {&#10;        if(message != null) notificationLog.add(message);&#10;    }&#10;&#10;    /**&#10;     * Subscribe a user to receive notifications from this event. Duplicates are ignored.&#10;     *&#10;     * @param user non-null user to subscribe&#10;     */&#10;    public void subscribe(User user) {&#10;        if(user != null &amp;&amp; !subscribers.contains(user)) {&#10;            subscribers.add(user);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Unsubscribe a user from this event.&#10;     *&#10;     * @param user user to remove (no-op if not subscribed)&#10;     */&#10;    public void unsubscribe(User user) {&#10;        subscribers.remove(user);&#10;    }&#10;&#10;    /**&#10;     * Notify all subscribers with a message and append it to the local notification log.&#10;     * Implemented as simple console output per subscriber for demo purposes.&#10;     *&#10;     * @param message message to broadcast&#10;     */&#10;    protected void notifySubscribers(String message) {&#10;        String full = &quot;[Event &quot; + id + &quot;:&quot; + name + &quot;] &quot; + message;&#10;        notificationLog.add(full);&#10;        for (User u : subscribers) {&#10;            // push notification into user's inbox&#10;            u.receiveNotification(full);&#10;            System.out.println(&quot;[Notify &quot; + u.getUsername() + &quot;] &quot; + full);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/domain/RaceEvent.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/domain/RaceEvent.java" />
              <option name="originalContent" value="package domain;&#10;&#10;import java.util.ArrayList;&#10;import java.util.Comparator;&#10;import java.util.List;&#10;import java.util.stream.Collectors;&#10;&#10;/**&#10; * Special event for swimming ducks. It auto-selects M ducks according to&#10; * simple swimming criteria and simulates the race.&#10; */&#10;public class RaceEvent extends Event {&#10;    private final int lanes; // M&#10;    private final List&lt;Duck&gt; participants = new ArrayList&lt;&gt;();&#10;    private double[] distances; // per-lane distances&#10;&#10;    /**&#10;     * Construct a race event with the specified number of lanes (M). Distances default to 1.0.&#10;     *&#10;     * @param id    event id&#10;     * @param name  event name&#10;     * @param lanes number of lanes (M &gt; 0)&#10;     */&#10;    public RaceEvent(int id, String name, int lanes) {&#10;        super(id, name);&#10;        if(lanes &lt;= 0) throw new IllegalArgumentException(&quot;lanes must be &gt; 0&quot;);&#10;        this.lanes = lanes;&#10;        this.distances = new double[lanes];&#10;        for (int i = 0; i &lt; lanes; i++) this.distances[i] = 1.0; // default&#10;    }&#10;&#10;    /**&#10;     * @return number of lanes (M) in this race&#10;     */&#10;    public int getLanes() { return lanes; }&#10;&#10;    /**&#10;     * @return the currently selected race participants (read-only snapshot semantics)&#10;     */&#10;    public List&lt;Duck&gt; getParticipants() { return participants; }&#10;&#10;    /**&#10;     * @return defensive copy of the configured lane distances&#10;     */&#10;    public double[] getDistances() {&#10;        return distances.clone();&#10;    }&#10;&#10;    /**&#10;     * Set the per-lane distances, must have exactly M entries.&#10;     *&#10;     * @param distances distances per lane&#10;     * @throws IllegalArgumentException if array is null or its length != M&#10;     */&#10;    public void setDistances(double[] distances){&#10;        if(distances == null || distances.length != lanes) throw new IllegalArgumentException(&quot;distances length must be M&quot;);&#10;        this.distances = distances;&#10;    }&#10;&#10;    /**&#10;     * Select up to M participant ducks from the provided list, filtering to swimmers (Inotator)&#10;     * and sorting by speed desc, then endurance desc.&#10;     *&#10;     * @param allDucks candidate ducks (may contain non-swimmers)&#10;     */&#10;    public void selectParticipants(List&lt;Duck&gt; allDucks){&#10;        participants.clear();&#10;        if(allDucks == null) return;&#10;        List&lt;Duck&gt; swimmers = allDucks.stream()&#10;                .filter(d -&gt; d instanceof Inotator)&#10;                .sorted(Comparator.comparingDouble(Duck::getViteza).reversed()&#10;                        .thenComparing(Comparator.comparingDouble(Duck::getRezistenta).reversed()))&#10;                .limit(lanes)&#10;                .collect(Collectors.toList());&#10;        participants.addAll(swimmers);&#10;        notifySubscribers(&quot;Race participants selected: &quot; + participants.stream().map(Duck::getUsername).collect(Collectors.joining(&quot;, &quot;)));&#10;    }&#10;&#10;    /**&#10;     * Run the race using the current participants and configured distances and return a textual&#10;     * report per lane (one line per lane assigned) plus a final line with the minimal total time.&#10;     *&#10;     * @return list of report lines describing per-lane assignments and minimal total time&#10;     */&#10;    public List&lt;String&gt; runRaceAndReport(){&#10;        List&lt;String&gt; report = new ArrayList&lt;&gt;();&#10;        if(participants.isEmpty()){&#10;            report.add(&quot;No participants selected.&quot;);&#10;            return report;&#10;        }&#10;        util.OptimizationStrategy opt = new util.BinarySearchSwimOptimizer();&#10;        util.SolveResult result = opt.computeMinTime(participants.toArray(new Duck[0]), distances);&#10;        Duck[] assignment = result.getAssignments();&#10;        double minimalTime = result.getMinimalTime();&#10;&#10;        for (int i = 0; i &lt; assignment.length; i++) {&#10;            Duck d = assignment[i];&#10;            if (d == null) continue;&#10;            int lane = i + 1;&#10;            double t = (2.0 * distances[i]) / d.getViteza();&#10;            report.add(String.format(&quot;Duck %d on lane %d: t = %.3f s&quot;, d.getId(), lane, t));&#10;        }&#10;        report.add(String.format(&quot;Minimal total time: %.3f s&quot;, minimalTime));&#10;        notifySubscribers(&quot;Race finished. Results available.&quot;);&#10;        return report;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package domain;&#10;&#10;import java.util.ArrayList;&#10;import java.util.Comparator;&#10;import java.util.List;&#10;import java.util.stream.Collectors;&#10;&#10;/**&#10; * Special event for swimming ducks. It auto-selects M ducks according to&#10; * simple swimming criteria and simulates the race.&#10; */&#10;public class RaceEvent extends Event {&#10;    private final int lanes; // M&#10;    private final List&lt;Duck&gt; participants = new ArrayList&lt;&gt;();&#10;    private double[] distances; // per-lane distances&#10;&#10;    /**&#10;     * Construct a race event with the specified number of lanes (M). Distances default to 1.0.&#10;     *&#10;     * @param id    event id&#10;     * @param name  event name&#10;     * @param lanes number of lanes (M &gt; 0)&#10;     */&#10;    public RaceEvent(int id, String name, int lanes) {&#10;        super(id, name);&#10;        if(lanes &lt;= 0) throw new IllegalArgumentException(&quot;lanes must be &gt; 0&quot;);&#10;        this.lanes = lanes;&#10;        this.distances = new double[lanes];&#10;        for (int i = 0; i &lt; lanes; i++) this.distances[i] = 1.0; // default&#10;    }&#10;&#10;    /**&#10;     * @return number of lanes (M) in this race&#10;     */&#10;    public int getLanes() { return lanes; }&#10;&#10;    /**&#10;     * @return the currently selected race participants (read-only snapshot semantics)&#10;     */&#10;    public List&lt;Duck&gt; getParticipants() { return participants; }&#10;&#10;    /**&#10;     * @return defensive copy of the configured lane distances&#10;     */&#10;    public double[] getDistances() {&#10;        return distances.clone();&#10;    }&#10;&#10;    /**&#10;     * Set the per-lane distances, must have exactly M entries.&#10;     *&#10;     * @param distances distances per lane&#10;     * @throws IllegalArgumentException if array is null or its length != M&#10;     */&#10;    public void setDistances(double[] distances){&#10;        if(distances == null || distances.length != lanes) throw new IllegalArgumentException(&quot;distances length must be M&quot;);&#10;        this.distances = distances;&#10;    }&#10;&#10;    /**&#10;     * Select up to M participant ducks from the provided list, filtering to swimmers (Inotator)&#10;     * and sorting by speed desc, then endurance desc.&#10;     *&#10;     * @param allDucks candidate ducks (may contain non-swimmers)&#10;     */&#10;    public void selectParticipants(List&lt;Duck&gt; allDucks){&#10;        participants.clear();&#10;        if(allDucks == null) return;&#10;        List&lt;Duck&gt; swimmers = allDucks.stream()&#10;                .filter(d -&gt; d instanceof Inotator)&#10;                .sorted(Comparator.comparingDouble(Duck::getViteza).reversed()&#10;                        .thenComparing(Comparator.comparingDouble(Duck::getRezistenta).reversed()))&#10;                .limit(lanes)&#10;                .collect(Collectors.toList());&#10;        participants.addAll(swimmers);&#10;        notifySubscribers(&quot;Race participants selected: &quot; + participants.stream().map(Duck::getUsername).collect(Collectors.joining(&quot;, &quot;)));&#10;    }&#10;&#10;    /**&#10;     * Run the race using the current participants and configured distances and return a textual&#10;     * report per lane (one line per lane assigned) plus a final line with the minimal total time.&#10;     *&#10;     * @return list of report lines describing per-lane assignments and minimal total time&#10;     */&#10;    public List&lt;String&gt; runRaceAndReport(){&#10;        List&lt;String&gt; report = new ArrayList&lt;&gt;();&#10;        if(participants.isEmpty()){&#10;            report.add(&quot;No participants selected.&quot;);&#10;            return report;&#10;        }&#10;        util.OptimizationStrategy opt = new util.BinarySearchSwimOptimizer();&#10;        util.SolveResult result = opt.computeMinTime(participants.toArray(new Duck[0]), distances);&#10;        Duck[] assignment = result.getAssignments();&#10;        double minimalTime = result.getMinimalTime();&#10;&#10;        for (int i = 0; i &lt; assignment.length; i++) {&#10;            Duck d = assignment[i];&#10;            if (d == null) continue;&#10;            int lane = i + 1;&#10;            double t = (2.0 * distances[i]) / d.getViteza();&#10;            report.add(String.format(&quot;Duck %d on lane %d: t = %.3f s&quot;, d.getId(), lane, t));&#10;        }&#10;        report.add(String.format(&quot;Minimal total time: %.3f s&quot;, minimalTime));&#10;        notifySubscribers(&quot;Race finished. Results available.&quot;);&#10;        return report;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/domain/User.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/domain/User.java" />
              <option name="originalContent" value="package domain;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Collections;&#10;&#10;/**&#10; * Base abstract class that represents a user in the social network.&#10; * Concrete subclasses (e.g. Persoana, Duck) add domain-specific fields.&#10; */&#10;public abstract class User {&#10;    protected int id;&#10;    protected String username,email,password;&#10;    protected List&lt;User&gt; friends;&#10;    /** Per-user notification inbox populated by subscribed events. */&#10;    private final List&lt;String&gt; notifications = new ArrayList&lt;&gt;();&#10;&#10;    /**&#10;     * Create a new User.&#10;     *&#10;     * @param id unique identifier for the user&#10;     * @param name username (display name)&#10;     * @param email user's email address&#10;     * @param password user's password&#10;     */&#10;    public User(int id, String name, String email, String password) {&#10;        this.id = id;&#10;        this.username = name;&#10;        this.email = email;&#10;        this.password = password;&#10;        this.friends=new ArrayList&lt;User&gt;();&#10;    }&#10;&#10;    public User(String name, String email, String password) {&#10;        this.id=-1; // uninitialized&#10;        this.username = name;&#10;        this.email = email;&#10;        this.password = password;&#10;        this.friends=new ArrayList&lt;User&gt;();&#10;    }&#10;&#10;    /**&#10;     * Add a friend to this user's friend list if not already present and not the same user.&#10;     *&#10;     * @param user the user to add as a friend&#10;     */&#10;    public void addFriend(User user){&#10;        if(!friends.contains(user) &amp;&amp; !this.equals(user)){&#10;            friends.add(user);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get the user's id.&#10;     *&#10;     * @return numeric id&#10;     */&#10;    public int getId() {&#10;        return id;&#10;    }&#10;&#10;    /**&#10;     * Assign a persistent id once it is generated by the repository layer.&#10;     * Subsequent calls replace the old value so reloads can keep their ids in sync.&#10;     */&#10;    public void setId(int id) {&#10;        this.id = id;&#10;    }&#10;&#10;    /**&#10;     * Get the user's username.&#10;     *&#10;     * @return username string&#10;     */&#10;    public String getUsername() {&#10;        return username;&#10;    }&#10;&#10;    /**&#10;     * Get the user's email address.&#10;     *&#10;     * @return email&#10;     */&#10;    public String getEmail() {&#10;        return email;&#10;    }&#10;&#10;    /**&#10;     * Get the user's password (plain text in this simple example).&#10;     *&#10;     * @return password&#10;     */&#10;    public String getPassword() {&#10;        return password;&#10;    }&#10;&#10;    /**&#10;     * Get this user's friends list.&#10;     *&#10;     * @return mutable list of friends&#10;     */&#10;    public List&lt;User&gt; getFriends() {&#10;        return friends;&#10;    }&#10;&#10;    /**&#10;     * Remove a friend from this user's friend list.&#10;     *&#10;     * @param user the friend to remove&#10;     */&#10;    public void removeFriend(User user){&#10;        friends.remove(user);&#10;    }&#10;&#10;    /**&#10;     * Receive a notification message from an observed event.&#10;     * Events call this when broadcasting updates to subscribers.&#10;     *&#10;     * @param message the message to store (ignored if null)&#10;     */&#10;    public void receiveNotification(String message){&#10;        if(message != null) notifications.add(message);&#10;    }&#10;&#10;    /**&#10;     * Read-only view of this user's notifications (in chronological order).&#10;     *&#10;     * @return unmodifiable list of notification messages&#10;     */&#10;    public List&lt;String&gt; getNotifications(){&#10;        return Collections.unmodifiableList(notifications);&#10;    }&#10;&#10;    @Override&#10;    public String toString() {&#10;        return &quot;User{&quot; +&#10;                &quot;id=&quot; + id +&#10;                &quot;, username='&quot; + username + '\'' +&#10;                &quot;, email='&quot; + email + '\'' +&#10;                &quot;, friends=&quot; + friends.size() +&#10;                '}';&#10;    }&#10;&#10;    @Override&#10;    public boolean equals(Object obj) {&#10;        if (this == obj) return true;&#10;        if(obj==null || getClass()!=obj.getClass()) return false;&#10;        User other=(User) obj;&#10;        return this.id==other.id;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package domain;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Collections;&#10;&#10;/**&#10; * Base abstract class that represents a user in the social network.&#10; * Concrete subclasses (e.g. Persoana, Duck) add domain-specific fields.&#10; */&#10;public abstract class User {&#10;    protected int id;&#10;    protected String username,email,password;&#10;    protected List&lt;User&gt; friends;&#10;    /** Per-user notification inbox populated by subscribed events. */&#10;    private final List&lt;String&gt; notifications = new ArrayList&lt;&gt;();&#10;&#10;    /**&#10;     * Create a new User.&#10;     *&#10;     * @param id unique identifier for the user&#10;     * @param name username (display name)&#10;     * @param email user's email address&#10;     * @param password user's password&#10;     */&#10;    public User(int id, String name, String email, String password) {&#10;        this.id = id;&#10;        this.username = name;&#10;        this.email = email;&#10;        this.password = password;&#10;        this.friends=new ArrayList&lt;User&gt;();&#10;    }&#10;&#10;    public User(String name, String email, String password) {&#10;        this.id=-1; // uninitialized&#10;        this.username = name;&#10;        this.email = email;&#10;        this.password = password;&#10;        this.friends=new ArrayList&lt;User&gt;();&#10;    }&#10;&#10;    /**&#10;     * Add a friend to this user's friend list if not already present and not the same user.&#10;     *&#10;     * @param user the user to add as a friend&#10;     */&#10;    public void addFriend(User user){&#10;        if(!friends.contains(user) &amp;&amp; !this.equals(user)){&#10;            friends.add(user);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get the user's id.&#10;     *&#10;     * @return numeric id&#10;     */&#10;    public int getId() {&#10;        return id;&#10;    }&#10;&#10;    /**&#10;     * Assign a persistent id once it is generated by the repository layer.&#10;     * Subsequent calls replace the old value so reloads can keep their ids in sync.&#10;     */&#10;    public void setId(int id) {&#10;        this.id = id;&#10;    }&#10;&#10;    /**&#10;     * Get the user's username.&#10;     *&#10;     * @return username string&#10;     */&#10;    public String getUsername() {&#10;        return username;&#10;    }&#10;&#10;    /**&#10;     * Get the user's email address.&#10;     *&#10;     * @return email&#10;     */&#10;    public String getEmail() {&#10;        return email;&#10;    }&#10;&#10;    /**&#10;     * Get the user's password (plain text in this simple example).&#10;     *&#10;     * @return password&#10;     */&#10;    public String getPassword() {&#10;        return password;&#10;    }&#10;&#10;    /**&#10;     * Get this user's friends list.&#10;     *&#10;     * @return mutable list of friends&#10;     */&#10;    public List&lt;User&gt; getFriends() {&#10;        return friends;&#10;    }&#10;&#10;    /**&#10;     * Remove a friend from this user's friend list.&#10;     *&#10;     * @param user the friend to remove&#10;     */&#10;    public void removeFriend(User user){&#10;        friends.remove(user);&#10;    }&#10;&#10;    /**&#10;     * Receive a notification message from an observed event.&#10;     * Events call this when broadcasting updates to subscribers.&#10;     *&#10;     * @param message the message to store (ignored if null)&#10;     */&#10;    public void receiveNotification(String message){&#10;        if(message != null) notifications.add(message);&#10;    }&#10;&#10;    /**&#10;     * Read-only view of this user's notifications (in chronological order).&#10;     *&#10;     * @return unmodifiable list of notification messages&#10;     */&#10;    public List&lt;String&gt; getNotifications(){&#10;        return Collections.unmodifiableList(notifications);&#10;    }&#10;&#10;    @Override&#10;    public String toString() {&#10;        return &quot;User{&quot; +&#10;                &quot;id=&quot; + id +&#10;                &quot;, username='&quot; + username + '\'' +&#10;                &quot;, email='&quot; + email + '\'' +&#10;                &quot;, friends=&quot; + friends.size() +&#10;                '}';&#10;    }&#10;&#10;    @Override&#10;    public boolean equals(Object obj) {&#10;        if (this == obj) return true;&#10;        if(obj==null || getClass()!=obj.getClass()) return false;&#10;        User other=(User) obj;&#10;        return this.id==other.id;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/repo/CardRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/repo/CardRepository.java" />
              <option name="originalContent" value="package repo;&#10;&#10;import domain.Card;&#10;&#10;/**&#10; * Repository specialization for {@link Card} aggregates.&#10; */&#10;public interface CardRepository extends Repository&lt;Integer, Card&gt; {&#10;    /**&#10;     * Persist the association between a card and a duck member.&#10;     */&#10;    void addDuck(int cardId, int duckId);&#10;&#10;    /**&#10;     * Remove the association between a card and a duck member.&#10;     */&#10;    void removeDuck(int cardId, int duckId);&#10;&#10;    /**&#10;     * Remove the association between all cards and a duck member.&#10;     */&#10;    void removeDuckFromAll(int duckId);&#10;}" />
              <option name="updatedContent" value="package repo;&#10;&#10;import domain.Card;&#10;&#10;/**&#10; * Repository specialization for {@link Card} aggregates.&#10; */&#10;public interface CardRepository extends Repository&lt;Integer, Card&gt; {&#10;    /**&#10;     * Persist the association between a card and a duck member.&#10;     */&#10;    void addDuck(int cardId, int duckId);&#10;&#10;    /**&#10;     * Remove the association between a card and a duck member.&#10;     */&#10;    void removeDuck(int cardId, int duckId);&#10;&#10;    /**&#10;     * Remove the association between all cards and a duck member.&#10;     */&#10;    void removeDuckFromAll(int duckId);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/repo/PostgresCardRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/repo/PostgresCardRepository.java" />
              <option name="originalContent" value="package repo;&#10;&#10;import domain.Card;&#10;import domain.Duck;&#10;import domain.User;&#10;import errors.RepoError;&#10;&#10;import java.sql.*;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Objects;&#10;&#10;/**&#10; * JDBC-backed repository for {@link Card} aggregates.&#10; */&#10;public class PostgresCardRepository implements CardRepository {&#10;    private final String url;&#10;    private final String user;&#10;    private final String password;&#10;    private final UserRepository userRepository;&#10;&#10;    public PostgresCardRepository(String url, String user, String password, UserRepository userRepository) {&#10;        this.url = url;&#10;        this.user = user;&#10;        this.password = password;&#10;        this.userRepository = Objects.requireNonNull(userRepository, &quot;userRepository&quot;);&#10;    }&#10;&#10;    private Connection getConnection() throws SQLException {&#10;        return DriverManager.getConnection(url, user, password);&#10;    }&#10;&#10;    @Override&#10;    public Card findOne(Integer id) {&#10;        if (id == null) throw new IllegalArgumentException(&quot;id is null&quot;);&#10;        String sql = &quot;SELECT id, nume_card FROM card WHERE id = ?&quot;;&#10;        try (Connection c = getConnection(); PreparedStatement ps = c.prepareStatement(sql)) {&#10;            ps.setInt(1, id);&#10;            try (ResultSet rs = ps.executeQuery()) {&#10;                if (!rs.next()) return null;&#10;                Card card = new Card(rs.getInt(&quot;id&quot;), rs.getString(&quot;nume_card&quot;));&#10;                loadMembers(c, card);&#10;                return card;&#10;            }&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB findOne error: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    private void loadMembers(Connection c, Card card) throws SQLException {&#10;        String sql = &quot;SELECT duck_id FROM card_duck WHERE card_id = ?&quot;;&#10;        try (PreparedStatement ps = c.prepareStatement(sql)) {&#10;            ps.setInt(1, card.getId());&#10;            try (ResultSet rs = ps.executeQuery()) {&#10;                while (rs.next()) {&#10;                    int duckId = rs.getInt(&quot;duck_id&quot;);&#10;                    User member = userRepository.findOne(duckId);&#10;                    if (member instanceof Duck duck) {&#10;                        card.addDuck(duck);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public Iterable&lt;Card&gt; findAll() {&#10;        List&lt;Card&gt; cards = new ArrayList&lt;&gt;();&#10;        String sql = &quot;SELECT id FROM card ORDER BY id&quot;;&#10;        try (Connection c = getConnection(); Statement st = c.createStatement(); ResultSet rs = st.executeQuery(sql)) {&#10;            while (rs.next()) {&#10;                cards.add(findOne(rs.getInt(&quot;id&quot;)));&#10;            }&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB findAll error: &quot; + e.getMessage());&#10;        }&#10;        return cards;&#10;    }&#10;&#10;    @Override&#10;    public Card save(Card entity) throws RepoError {&#10;        if (entity == null) throw new IllegalArgumentException(&quot;entity is null&quot;);&#10;        String sql = &quot;INSERT INTO card(nume_card) VALUES (?) RETURNING id&quot;;&#10;        try (Connection c = getConnection(); PreparedStatement ps = c.prepareStatement(sql)) {&#10;            ps.setString(1, entity.getNumeCard());&#10;            try (ResultSet rs = ps.executeQuery()) {&#10;                if (rs.next()) {&#10;                    int generatedId = rs.getInt(1);&#10;                    // create a new Card instance with the generated id&#10;                    return new Card(generatedId, entity.getNumeCard());&#10;                } else {&#10;                    throw new RepoError(&quot;Failed to generate card id&quot;);&#10;                }&#10;            }&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB save error: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public Card delete(Integer id) {&#10;        if (id == null) throw new IllegalArgumentException(&quot;id is null&quot;);&#10;        Card existing = findOne(id);&#10;        if (existing == null) return null;&#10;        String sql = &quot;DELETE FROM card WHERE id = ?&quot;;&#10;        try (Connection c = getConnection(); PreparedStatement ps = c.prepareStatement(sql)) {&#10;            ps.setInt(1, id);&#10;            ps.executeUpdate();&#10;            return existing;&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB delete error: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void addDuck(int cardId, int duckId) {&#10;        String sql = &quot;INSERT INTO card_duck(card_id, duck_id) VALUES (?, ?) ON CONFLICT DO NOTHING&quot;;&#10;        try (Connection c = getConnection(); PreparedStatement ps = c.prepareStatement(sql)) {&#10;            ps.setInt(1, cardId);&#10;            ps.setInt(2, duckId);&#10;            ps.executeUpdate();&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB addDuck error: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void removeDuck(int cardId, int duckId) {&#10;        String sql = &quot;DELETE FROM card_duck WHERE card_id = ? AND duck_id = ?&quot;;&#10;        try (Connection c = getConnection(); PreparedStatement ps = c.prepareStatement(sql)) {&#10;            ps.setInt(1, cardId);&#10;            ps.setInt(2, duckId);&#10;            ps.executeUpdate();&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB removeDuck error: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void removeDuckFromAll(int duckId) {&#10;        String sql = &quot;DELETE FROM card_duck WHERE duck_id = ?&quot;;&#10;        try (Connection c = getConnection(); PreparedStatement ps = c.prepareStatement(sql)) {&#10;            ps.setInt(1, duckId);&#10;            ps.executeUpdate();&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB removeDuckFromAll error: &quot; + e.getMessage());&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package repo;&#10;&#10;import domain.Card;&#10;import domain.Duck;&#10;import domain.User;&#10;import errors.RepoError;&#10;&#10;import java.sql.*;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Objects;&#10;&#10;/**&#10; * JDBC-backed repository for {@link Card} aggregates.&#10; */&#10;public class PostgresCardRepository implements CardRepository {&#10;    private final String url;&#10;    private final String user;&#10;    private final String password;&#10;    private final UserRepository userRepository;&#10;&#10;    public PostgresCardRepository(String url, String user, String password, UserRepository userRepository) {&#10;        this.url = url;&#10;        this.user = user;&#10;        this.password = password;&#10;        this.userRepository = Objects.requireNonNull(userRepository, &quot;userRepository&quot;);&#10;    }&#10;&#10;    private Connection getConnection() throws SQLException {&#10;        return DriverManager.getConnection(url, user, password);&#10;    }&#10;&#10;    @Override&#10;    public Card findOne(Integer id) {&#10;        if (id == null) throw new IllegalArgumentException(&quot;id is null&quot;);&#10;        String sql = &quot;SELECT id, nume_card FROM card WHERE id = ?&quot;;&#10;        try (Connection c = getConnection(); PreparedStatement ps = c.prepareStatement(sql)) {&#10;            ps.setInt(1, id);&#10;            try (ResultSet rs = ps.executeQuery()) {&#10;                if (!rs.next()) return null;&#10;                Card card = new Card(rs.getInt(&quot;id&quot;), rs.getString(&quot;nume_card&quot;));&#10;                loadMembers(c, card);&#10;                return card;&#10;            }&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB findOne error: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    private void loadMembers(Connection c, Card card) throws SQLException {&#10;        String sql = &quot;SELECT duck_id FROM card_duck WHERE card_id = ?&quot;;&#10;        try (PreparedStatement ps = c.prepareStatement(sql)) {&#10;            ps.setInt(1, card.getId());&#10;            try (ResultSet rs = ps.executeQuery()) {&#10;                while (rs.next()) {&#10;                    int duckId = rs.getInt(&quot;duck_id&quot;);&#10;                    User member = userRepository.findOne(duckId);&#10;                    if (member instanceof Duck duck) {&#10;                        card.addDuck(duck);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public Iterable&lt;Card&gt; findAll() {&#10;        List&lt;Card&gt; cards = new ArrayList&lt;&gt;();&#10;        String sql = &quot;SELECT id FROM card ORDER BY id&quot;;&#10;        try (Connection c = getConnection(); Statement st = c.createStatement(); ResultSet rs = st.executeQuery(sql)) {&#10;            while (rs.next()) {&#10;                cards.add(findOne(rs.getInt(&quot;id&quot;)));&#10;            }&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB findAll error: &quot; + e.getMessage());&#10;        }&#10;        return cards;&#10;    }&#10;&#10;    @Override&#10;    public Card save(Card entity) throws RepoError {&#10;        if (entity == null) throw new IllegalArgumentException(&quot;entity is null&quot;);&#10;        String sql = &quot;INSERT INTO card(nume_card) VALUES (?) RETURNING id&quot;;&#10;        try (Connection c = getConnection(); PreparedStatement ps = c.prepareStatement(sql)) {&#10;            ps.setString(1, entity.getNumeCard());&#10;            try (ResultSet rs = ps.executeQuery()) {&#10;                if (rs.next()) {&#10;                    int generatedId = rs.getInt(1);&#10;                    // create a new Card instance with the generated id&#10;                    return new Card(generatedId, entity.getNumeCard());&#10;                } else {&#10;                    throw new RepoError(&quot;Failed to generate card id&quot;);&#10;                }&#10;            }&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB save error: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public Card delete(Integer id) {&#10;        if (id == null) throw new IllegalArgumentException(&quot;id is null&quot;);&#10;        Card existing = findOne(id);&#10;        if (existing == null) return null;&#10;        String sql = &quot;DELETE FROM card WHERE id = ?&quot;;&#10;        try (Connection c = getConnection(); PreparedStatement ps = c.prepareStatement(sql)) {&#10;            ps.setInt(1, id);&#10;            ps.executeUpdate();&#10;            return existing;&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB delete error: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void addDuck(int cardId, int duckId) {&#10;        String sql = &quot;INSERT INTO card_duck(card_id, duck_id) VALUES (?, ?) ON CONFLICT DO NOTHING&quot;;&#10;        try (Connection c = getConnection(); PreparedStatement ps = c.prepareStatement(sql)) {&#10;            ps.setInt(1, cardId);&#10;            ps.setInt(2, duckId);&#10;            ps.executeUpdate();&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB addDuck error: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void removeDuck(int cardId, int duckId) {&#10;        String sql = &quot;DELETE FROM card_duck WHERE card_id = ? AND duck_id = ?&quot;;&#10;        try (Connection c = getConnection(); PreparedStatement ps = c.prepareStatement(sql)) {&#10;            ps.setInt(1, cardId);&#10;            ps.setInt(2, duckId);&#10;            ps.executeUpdate();&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB removeDuck error: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void removeDuckFromAll(int duckId) {&#10;        String sql = &quot;DELETE FROM card_duck WHERE duck_id = ?&quot;;&#10;        try (Connection c = getConnection(); PreparedStatement ps = c.prepareStatement(sql)) {&#10;            ps.setInt(1, duckId);&#10;            ps.executeUpdate();&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB removeDuckFromAll error: &quot; + e.getMessage());&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/repo/PostgresEventRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/repo/PostgresEventRepository.java" />
              <option name="originalContent" value="package repo;&#10;&#10;import domain.Duck;&#10;import domain.Event;&#10;import domain.RaceEvent;&#10;import domain.User;&#10;import errors.RepoError;&#10;&#10;import java.sql.*;&#10;import java.util.ArrayList;&#10;import java.util.Arrays;&#10;import java.util.List;&#10;import java.util.Objects;&#10;&#10;/**&#10; * JDBC-based repository for persisting Event and RaceEvent entities&#10; * in a PostgreSQL database.&#10; *&#10; * Tables used:&#10; *   events(id, name, type)&#10; *   race_events(event_id FK -&gt; events.id, lanes, distances)&#10; *   race_participants(race_event_id FK -&gt; race_events.event_id, duck_id FK -&gt; duck.id, lane)&#10; *   event_subscribers(event_id FK -&gt; events.id, user_id FK -&gt; user_base.id)&#10; *   event_notifications(id, event_id FK -&gt; events.id, message, created_at)&#10; */&#10;public class PostgresEventRepository implements EventRepository {&#10;    private final String url;&#10;    private final String user;&#10;    private final String password;&#10;    private final UserRepository userRepository;&#10;&#10;    public PostgresEventRepository(String url, String user, String password, UserRepository userRepository) {&#10;        this.url = url;&#10;        this.user = user;&#10;        this.password = password;&#10;        this.userRepository = Objects.requireNonNull(userRepository, &quot;userRepository&quot;);&#10;    }&#10;&#10;    private Connection getConnection() throws SQLException {&#10;        return DriverManager.getConnection(url, user, password);&#10;    }&#10;&#10;    @Override&#10;    public Event findOne(Integer id) {&#10;        if (id == null) throw new IllegalArgumentException(&quot;id is null&quot;);&#10;&#10;        try (Connection c = getConnection()) {&#10;            // Load base event&#10;            String sqlEvent = &quot;SELECT id, name, type FROM events WHERE id = ?&quot;;&#10;            Event event;&#10;            try (PreparedStatement ps = c.prepareStatement(sqlEvent)) {&#10;                ps.setInt(1, id);&#10;                try (ResultSet rs = ps.executeQuery()) {&#10;                    if (!rs.next()) return null;&#10;                    String name = rs.getString(&quot;name&quot;);&#10;                    String type = rs.getString(&quot;type&quot;);&#10;                    if (&quot;RACE&quot;.equals(type)) {&#10;                        event = loadRaceEvent(c, id, name);&#10;                    } else {&#10;                        event = new Event(id, name);&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Load subscribers&#10;            String sqlSubs = &quot;SELECT user_id FROM event_subscribers WHERE event_id = ?&quot;;&#10;            try (PreparedStatement ps = c.prepareStatement(sqlSubs)) {&#10;                ps.setInt(1, id);&#10;                try (ResultSet rs = ps.executeQuery()) {&#10;                    while (rs.next()) {&#10;                        int userId = rs.getInt(&quot;user_id&quot;);&#10;                        User subscriber = userRepository.findOne(userId);&#10;                        if (subscriber != null) {&#10;                            event.attachSubscriber(subscriber);&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Load notifications&#10;            String sqlNotifs = &quot;SELECT message FROM event_notifications WHERE event_id = ? ORDER BY created_at&quot;;&#10;            try (PreparedStatement ps = c.prepareStatement(sqlNotifs)) {&#10;                ps.setInt(1, id);&#10;                try (ResultSet rs = ps.executeQuery()) {&#10;                    while (rs.next()) {&#10;                        event.appendNotification(rs.getString(&quot;message&quot;));&#10;                    }&#10;                }&#10;            }&#10;&#10;            return event;&#10;&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB findOne error: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    private RaceEvent loadRaceEvent(Connection c, int id, String name) throws SQLException {&#10;        String sql = &quot;SELECT lanes, distances FROM race_events WHERE event_id = ?&quot;;&#10;        try (PreparedStatement ps = c.prepareStatement(sql)) {&#10;            ps.setInt(1, id);&#10;            try (ResultSet rs = ps.executeQuery()) {&#10;                if (!rs.next()) throw new RepoError(&quot;RaceEvent data missing for id &quot; + id);&#10;                int lanes = rs.getInt(&quot;lanes&quot;);&#10;                Array distancesArray = rs.getArray(&quot;distances&quot;);&#10;                Double[] distances = (Double[]) distancesArray.getArray();&#10;                RaceEvent race = new RaceEvent(id, name, lanes);&#10;                race.setDistances(Arrays.stream(distances).mapToDouble(Double::doubleValue).toArray());&#10;&#10;                // load participants&#10;                String sqlPart = &quot;SELECT duck_id, lane FROM race_participants WHERE race_event_id = ? ORDER BY lane&quot;;&#10;                try (PreparedStatement psPart = c.prepareStatement(sqlPart)) {&#10;                    psPart.setInt(1, id);&#10;                    try (ResultSet rsPart = psPart.executeQuery()) {&#10;                        while (rsPart.next()) {&#10;                            int duckId = rsPart.getInt(&quot;duck_id&quot;);&#10;                            User participant = userRepository.findOne(duckId);&#10;                            if (participant instanceof Duck duck) {&#10;                                race.getParticipants().add(duck);&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;                return race;&#10;            }&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public Iterable&lt;Event&gt; findAll() {&#10;        List&lt;Event&gt; events = new ArrayList&lt;&gt;();&#10;        String sql = &quot;SELECT id FROM events ORDER BY id&quot;;&#10;        try (Connection c = getConnection();&#10;             Statement st = c.createStatement();&#10;             ResultSet rs = st.executeQuery(sql)) {&#10;            while (rs.next()) {&#10;                int id = rs.getInt(&quot;id&quot;);&#10;                events.add(findOne(id));&#10;            }&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB findAll error: &quot; + e.getMessage());&#10;        }&#10;        return events;&#10;    }&#10;&#10;    @Override&#10;    public Event save(Event entity) throws RepoError {&#10;        if (entity == null) throw new IllegalArgumentException(&quot;entity is null&quot;);&#10;        try (Connection c = getConnection()) {&#10;            c.setAutoCommit(false);&#10;&#10;            // Insert into events&#10;            String sqlEvent = &quot;INSERT INTO events(name, type) VALUES (?, ?) RETURNING id&quot;;&#10;            int generatedId;&#10;            try (PreparedStatement ps = c.prepareStatement(sqlEvent)) {&#10;                ps.setString(1, entity.getName());&#10;                ps.setString(2, entity instanceof RaceEvent ? &quot;RACE&quot; : &quot;EVENT&quot;);&#10;                try (ResultSet rs = ps.executeQuery()) {&#10;                    if (!rs.next()) throw new RepoError(&quot;Failed to generate event id&quot;);&#10;                    generatedId = rs.getInt(1);&#10;                }&#10;            }&#10;&#10;            // Insert race-specific data&#10;            if (entity instanceof RaceEvent race) {&#10;                String sqlRace = &quot;INSERT INTO race_events(event_id, lanes, distances) VALUES (?, ?, ?)&quot;;&#10;                try (PreparedStatement ps = c.prepareStatement(sqlRace)) {&#10;                    ps.setInt(1, generatedId);&#10;                    ps.setInt(2, race.getLanes());&#10;                    ps.setArray(3, c.createArrayOf(&quot;double precision&quot;, Arrays.stream(race.getDistances()).boxed().toArray(Double[]::new)));&#10;                    ps.executeUpdate();&#10;                }&#10;&#10;                // Insert participants&#10;                String sqlPart = &quot;INSERT INTO race_participants(race_event_id, duck_id, lane) VALUES (?, ?, ?)&quot;;&#10;                try (PreparedStatement ps = c.prepareStatement(sqlPart)) {&#10;                    int lane = 1;&#10;                    for (Duck d : race.getParticipants()) {&#10;                        ps.setInt(1, generatedId);&#10;                        ps.setInt(2, d.getId());&#10;                        ps.setInt(3, lane++);&#10;                        ps.addBatch();&#10;                    }&#10;                    ps.executeBatch();&#10;                }&#10;            }&#10;&#10;            c.commit();&#10;            return entity;&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB save error: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public Event delete(Integer id) {&#10;        if (id == null) throw new IllegalArgumentException(&quot;id is null&quot;);&#10;        Event existing = findOne(id);&#10;        if (existing == null) return null;&#10;        String sql = &quot;DELETE FROM events WHERE id = ?&quot;; // cascades to race_events, participants, subscribers, notifications&#10;        try (Connection c = getConnection(); PreparedStatement ps = c.prepareStatement(sql)) {&#10;            ps.setInt(1, id);&#10;            ps.executeUpdate();&#10;            return existing;&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB delete error: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    public void addSubscriber(int eventId, int userId) {&#10;        String sql = &quot;INSERT INTO event_subscribers(event_id, user_id) VALUES (?, ?) ON CONFLICT DO NOTHING&quot;;&#10;        try (Connection c = getConnection(); PreparedStatement ps = c.prepareStatement(sql)) {&#10;            ps.setInt(1, eventId);&#10;            ps.setInt(2, userId);&#10;            ps.executeUpdate();&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB addSubscriber error: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    public void removeSubscriber(int eventId, int userId) {&#10;        String sql = &quot;DELETE FROM event_subscribers WHERE event_id = ? AND user_id = ?&quot;;&#10;        try (Connection c = getConnection(); PreparedStatement ps = c.prepareStatement(sql)) {&#10;            ps.setInt(1, eventId);&#10;            ps.setInt(2, userId);&#10;            ps.executeUpdate();&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB removeSubscriber error: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    public void addNotification(int eventId, String message) {&#10;        String sql = &quot;INSERT INTO event_notifications(event_id, message) VALUES (?, ?)&quot;;&#10;        try (Connection c = getConnection(); PreparedStatement ps = c.prepareStatement(sql)) {&#10;            ps.setInt(1, eventId);&#10;            ps.setString(2, message);&#10;            ps.executeUpdate();&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB addNotification error: &quot; + e.getMessage());&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package repo;&#10;&#10;import domain.Duck;&#10;import domain.Event;&#10;import domain.RaceEvent;&#10;import domain.User;&#10;import errors.RepoError;&#10;&#10;import java.sql.*;&#10;import java.util.ArrayList;&#10;import java.util.Arrays;&#10;import java.util.List;&#10;import java.util.Objects;&#10;&#10;/**&#10; * JDBC-based repository for persisting Event and RaceEvent entities&#10; * in a PostgreSQL database.&#10; *&#10; * Tables used:&#10; *   events(id, name, type)&#10; *   race_events(event_id FK -&gt; events.id, lanes, distances)&#10; *   race_participants(race_event_id FK -&gt; race_events.event_id, duck_id FK -&gt; duck.id, lane)&#10; *   event_subscribers(event_id FK -&gt; events.id, user_id FK -&gt; user_base.id)&#10; *   event_notifications(id, event_id FK -&gt; events.id, message, created_at)&#10; */&#10;public class PostgresEventRepository implements EventRepository {&#10;    private final String url;&#10;    private final String user;&#10;    private final String password;&#10;    private final UserRepository userRepository;&#10;&#10;    public PostgresEventRepository(String url, String user, String password, UserRepository userRepository) {&#10;        this.url = url;&#10;        this.user = user;&#10;        this.password = password;&#10;        this.userRepository = Objects.requireNonNull(userRepository, &quot;userRepository&quot;);&#10;    }&#10;&#10;    private Connection getConnection() throws SQLException {&#10;        return DriverManager.getConnection(url, user, password);&#10;    }&#10;&#10;    @Override&#10;    public Event findOne(Integer id) {&#10;        if (id == null) throw new IllegalArgumentException(&quot;id is null&quot;);&#10;&#10;        try (Connection c = getConnection()) {&#10;            // Load base event&#10;            String sqlEvent = &quot;SELECT id, name, type FROM events WHERE id = ?&quot;;&#10;            Event event;&#10;            try (PreparedStatement ps = c.prepareStatement(sqlEvent)) {&#10;                ps.setInt(1, id);&#10;                try (ResultSet rs = ps.executeQuery()) {&#10;                    if (!rs.next()) return null;&#10;                    String name = rs.getString(&quot;name&quot;);&#10;                    String type = rs.getString(&quot;type&quot;);&#10;                    if (&quot;RACE&quot;.equals(type)) {&#10;                        event = loadRaceEvent(c, id, name);&#10;                    } else {&#10;                        event = new Event(id, name);&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Load subscribers&#10;            String sqlSubs = &quot;SELECT user_id FROM event_subscribers WHERE event_id = ?&quot;;&#10;            try (PreparedStatement ps = c.prepareStatement(sqlSubs)) {&#10;                ps.setInt(1, id);&#10;                try (ResultSet rs = ps.executeQuery()) {&#10;                    while (rs.next()) {&#10;                        int userId = rs.getInt(&quot;user_id&quot;);&#10;                        User subscriber = userRepository.findOne(userId);&#10;                        if (subscriber != null) {&#10;                            event.attachSubscriber(subscriber);&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Load notifications&#10;            String sqlNotifs = &quot;SELECT message FROM event_notifications WHERE event_id = ? ORDER BY created_at&quot;;&#10;            try (PreparedStatement ps = c.prepareStatement(sqlNotifs)) {&#10;                ps.setInt(1, id);&#10;                try (ResultSet rs = ps.executeQuery()) {&#10;                    while (rs.next()) {&#10;                        event.appendNotification(rs.getString(&quot;message&quot;));&#10;                    }&#10;                }&#10;            }&#10;&#10;            return event;&#10;&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB findOne error: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    private RaceEvent loadRaceEvent(Connection c, int id, String name) throws SQLException {&#10;        String sql = &quot;SELECT lanes, distances FROM race_events WHERE event_id = ?&quot;;&#10;        try (PreparedStatement ps = c.prepareStatement(sql)) {&#10;            ps.setInt(1, id);&#10;            try (ResultSet rs = ps.executeQuery()) {&#10;                if (!rs.next()) throw new RepoError(&quot;RaceEvent data missing for id &quot; + id);&#10;                int lanes = rs.getInt(&quot;lanes&quot;);&#10;                Array distancesArray = rs.getArray(&quot;distances&quot;);&#10;                Double[] distances = (Double[]) distancesArray.getArray();&#10;                RaceEvent race = new RaceEvent(id, name, lanes);&#10;                race.setDistances(Arrays.stream(distances).mapToDouble(Double::doubleValue).toArray());&#10;&#10;                // load participants&#10;                String sqlPart = &quot;SELECT duck_id, lane FROM race_participants WHERE race_event_id = ? ORDER BY lane&quot;;&#10;                try (PreparedStatement psPart = c.prepareStatement(sqlPart)) {&#10;                    psPart.setInt(1, id);&#10;                    try (ResultSet rsPart = psPart.executeQuery()) {&#10;                        while (rsPart.next()) {&#10;                            int duckId = rsPart.getInt(&quot;duck_id&quot;);&#10;                            User participant = userRepository.findOne(duckId);&#10;                            if (participant instanceof Duck duck) {&#10;                                race.getParticipants().add(duck);&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;                return race;&#10;            }&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public Iterable&lt;Event&gt; findAll() {&#10;        List&lt;Event&gt; events = new ArrayList&lt;&gt;();&#10;        String sql = &quot;SELECT id FROM events ORDER BY id&quot;;&#10;        try (Connection c = getConnection();&#10;             Statement st = c.createStatement();&#10;             ResultSet rs = st.executeQuery(sql)) {&#10;            while (rs.next()) {&#10;                int id = rs.getInt(&quot;id&quot;);&#10;                events.add(findOne(id));&#10;            }&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB findAll error: &quot; + e.getMessage());&#10;        }&#10;        return events;&#10;    }&#10;&#10;    @Override&#10;    public Event save(Event entity) throws RepoError {&#10;        if (entity == null) throw new IllegalArgumentException(&quot;entity is null&quot;);&#10;        try (Connection c = getConnection()) {&#10;            c.setAutoCommit(false);&#10;&#10;            // Insert into events&#10;            String sqlEvent = &quot;INSERT INTO events(name, type) VALUES (?, ?) RETURNING id&quot;;&#10;            int generatedId;&#10;            try (PreparedStatement ps = c.prepareStatement(sqlEvent)) {&#10;                ps.setString(1, entity.getName());&#10;                ps.setString(2, entity instanceof RaceEvent ? &quot;RACE&quot; : &quot;EVENT&quot;);&#10;                try (ResultSet rs = ps.executeQuery()) {&#10;                    if (!rs.next()) throw new RepoError(&quot;Failed to generate event id&quot;);&#10;                    generatedId = rs.getInt(1);&#10;                }&#10;            }&#10;&#10;            // Insert race-specific data&#10;            if (entity instanceof RaceEvent race) {&#10;                String sqlRace = &quot;INSERT INTO race_events(event_id, lanes, distances) VALUES (?, ?, ?)&quot;;&#10;                try (PreparedStatement ps = c.prepareStatement(sqlRace)) {&#10;                    ps.setInt(1, generatedId);&#10;                    ps.setInt(2, race.getLanes());&#10;                    ps.setArray(3, c.createArrayOf(&quot;double precision&quot;, Arrays.stream(race.getDistances()).boxed().toArray(Double[]::new)));&#10;                    ps.executeUpdate();&#10;                }&#10;&#10;                // Insert participants&#10;                String sqlPart = &quot;INSERT INTO race_participants(race_event_id, duck_id, lane) VALUES (?, ?, ?)&quot;;&#10;                try (PreparedStatement ps = c.prepareStatement(sqlPart)) {&#10;                    int lane = 1;&#10;                    for (Duck d : race.getParticipants()) {&#10;                        ps.setInt(1, generatedId);&#10;                        ps.setInt(2, d.getId());&#10;                        ps.setInt(3, lane++);&#10;                        ps.addBatch();&#10;                    }&#10;                    ps.executeBatch();&#10;                }&#10;            }&#10;&#10;            c.commit();&#10;            return entity;&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB save error: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public Event delete(Integer id) {&#10;        if (id == null) throw new IllegalArgumentException(&quot;id is null&quot;);&#10;        Event existing = findOne(id);&#10;        if (existing == null) return null;&#10;        String sql = &quot;DELETE FROM events WHERE id = ?&quot;; // cascades to race_events, participants, subscribers, notifications&#10;        try (Connection c = getConnection(); PreparedStatement ps = c.prepareStatement(sql)) {&#10;            ps.setInt(1, id);&#10;            ps.executeUpdate();&#10;            return existing;&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB delete error: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    public void addSubscriber(int eventId, int userId) {&#10;        String sql = &quot;INSERT INTO event_subscribers(event_id, user_id) VALUES (?, ?) ON CONFLICT DO NOTHING&quot;;&#10;        try (Connection c = getConnection(); PreparedStatement ps = c.prepareStatement(sql)) {&#10;            ps.setInt(1, eventId);&#10;            ps.setInt(2, userId);&#10;            ps.executeUpdate();&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB addSubscriber error: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    public void removeSubscriber(int eventId, int userId) {&#10;        String sql = &quot;DELETE FROM event_subscribers WHERE event_id = ? AND user_id = ?&quot;;&#10;        try (Connection c = getConnection(); PreparedStatement ps = c.prepareStatement(sql)) {&#10;            ps.setInt(1, eventId);&#10;            ps.setInt(2, userId);&#10;            ps.executeUpdate();&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB removeSubscriber error: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    public void addNotification(int eventId, String message) {&#10;        String sql = &quot;INSERT INTO event_notifications(event_id, message) VALUES (?, ?)&quot;;&#10;        try (Connection c = getConnection(); PreparedStatement ps = c.prepareStatement(sql)) {&#10;            ps.setInt(1, eventId);&#10;            ps.setString(2, message);&#10;            ps.executeUpdate();&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB addNotification error: &quot; + e.getMessage());&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/service/NetworkService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/service/NetworkService.java" />
              <option name="originalContent" value="package service;&#10;&#10;import domain.*;&#10;import errors.RepoError;&#10;import errors.ValidationError;&#10;import repo.EventRepository;&#10;import repo.UserRepository;&#10;import repo.PostgresUserRepository; // added&#10;import repo.PostgresEventRepository;&#10;import repo.CardRepository;&#10;&#10;import util.Algorithms;&#10;import validator.ValidationStrategy;&#10;&#10;import java.util.*;&#10;&#10;/**&#10; * Service layer that orchestrates repository access, validation and business&#10; * operations for the social network domain.&#10; */&#10;public class NetworkService {&#10;    private UserRepository userRepository;&#10;    private EventRepository eventRepository;&#10;    private ValidationStrategy&lt;Persoana&gt; persoanaValidator;&#10;    private ValidationStrategy&lt;Duck&gt; duckValidator;&#10;    private final Map&lt;Integer, Card&gt; cards = new HashMap&lt;&gt;();&#10;    private final CardRepository cardRepository;&#10;&#10;    /**&#10;     * Construct the NetworkService with required dependencies.&#10;     *&#10;     * @param userRepository repository for users&#10;     * @param eventRepository repository for events&#10;     * @param persoanaValidator validator for Persoana instances&#10;     * @param duckValidator validator for Duck instances&#10;     * @param cardRepository repository for cards&#10;     */&#10;    public NetworkService(UserRepository userRepository, EventRepository eventRepository, ValidationStrategy&lt;Persoana&gt; persoanaValidator, ValidationStrategy&lt;Duck&gt; duckValidator, CardRepository cardRepository) {&#10;        this.userRepository = userRepository;&#10;        this.eventRepository = eventRepository;&#10;        this.persoanaValidator = persoanaValidator;&#10;        this.duckValidator = duckValidator;&#10;        this.cardRepository = cardRepository;&#10;        if(cardRepository != null){&#10;            for (Card card : cardRepository.findAll()) {&#10;                cards.put(card.getId(), card);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Add a new user to the network after validating it.&#10;     *&#10;     * @param user the user to add (Persoana or Duck)&#10;     * @return the saved user&#10;     * @throws ValidationError when validation fails&#10;     * @throws RepoError when repository rejects the save (e.g. duplicate id)&#10;     */&#10;    public User addUser(User user) throws ValidationError, RepoError {&#10;        if(user instanceof Persoana){&#10;            persoanaValidator.validate((Persoana) user);&#10;        }&#10;        else if(user instanceof Duck){&#10;            duckValidator.validate((Duck) user);&#10;        }&#10;        else{&#10;            throw new ValidationError(&quot;Unknown user type&quot;);&#10;        }&#10;        return userRepository.save(user);&#10;    }&#10;&#10;    /**&#10;     * Remove a user by id and clean up references from other users' friend lists.&#10;     * Also removes a duck from all cards where it appears.&#10;     *&#10;     * @param id the id of the user to remove&#10;     * @return the removed user&#10;     * @throws RepoError when the user does not exist&#10;     */&#10;    public User removeUser(Integer id){&#10;        User userToRemove=userRepository.delete(id);&#10;        if(userToRemove==null){&#10;            throw new RepoError(&quot;User with id &quot;+id+&quot; not found&quot;);&#10;        }&#10;        for (User u: userRepository.findAll()) {&#10;            u.removeFriend(userToRemove);&#10;        }&#10;        // also remove from cards if it's a Duck&#10;        if (userToRemove instanceof Duck) {&#10;            Duck d = (Duck) userToRemove;&#10;            for (Card c : cards.values()) {&#10;                c.removeDuck(d);&#10;            }&#10;            if (cardRepository != null) {&#10;                cardRepository.removeDuckFromAll(d.getId());&#10;            }&#10;        }&#10;        return userToRemove;&#10;    }&#10;&#10;    /**&#10;     * Create a mutual friendship between two users identified by their ids.&#10;     *&#10;     * @param id1 first user's id&#10;     * @param id2 second user's id&#10;     * @throws RepoError when either user is not found&#10;     */&#10;    public void addFriendship(Integer id1, Integer id2){&#10;        User user1=userRepository.findOne(id1);&#10;        User user2=userRepository.findOne(id2);&#10;        if(user1==null){&#10;            throw new RepoError(&quot;User with id &quot;+id1+&quot; not found&quot;);&#10;        }&#10;        if(user2==null){&#10;            throw new RepoError(&quot;User with id &quot;+id2+&quot; not found&quot;);&#10;        }&#10;        user1.addFriend(user2);&#10;        user2.addFriend(user1);&#10;        if(userRepository instanceof PostgresUserRepository pr){&#10;            pr.saveFriendship(id1, id2);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Remove a mutual friendship between two users (if present).&#10;     *&#10;     * @param id1 first user's id&#10;     * @param id2 second user's id&#10;     */&#10;    public void removeFriendship(Integer id1, Integer id2){&#10;        User user1=userRepository.findOne(id1);&#10;        User user2=userRepository.findOne(id2);&#10;        if(user1!=null){&#10;            user1.removeFriend(user2);&#10;        }&#10;        if(user2!=null){&#10;            user2.removeFriend(user1);&#10;        }&#10;        if(userRepository instanceof PostgresUserRepository pr){&#10;            pr.deleteFriendship(id1, id2);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Retrieve all users in the network.&#10;     *&#10;     * @return iterable of all users&#10;     */&#10;    public Iterable&lt;User&gt; getAllUsers(){&#10;        return userRepository.findAll();&#10;    }&#10;&#10;    /**&#10;     * Compute the number of connected components (communities) in the network.&#10;     *&#10;     * @return number of communities&#10;     */&#10;    public int getNumberOfCommunities(){&#10;        Set&lt;User&gt; visited=new HashSet&lt;&gt;();&#10;        int communities=0;&#10;        for (User user: userRepository.findAll()) {&#10;            if(!visited.contains(user)){&#10;                communities++;&#10;                Algorithms.dfs(user, visited);&#10;            }&#10;        }&#10;        return communities;&#10;    }&#10;&#10;    /**&#10;     * Find the community with the largest diameter (most social community).&#10;     * The method returns the list of users in the community with the maximum&#10;     * shortest-path diameter.&#10;     *&#10;     * @return list of users forming the most social community&#10;     */&#10;    public List&lt;User&gt; getMostSocialCommunity() {&#10;        Set&lt;User&gt; visitedGlobal = new HashSet&lt;&gt;();&#10;        List&lt;User&gt; bestCommunity = new ArrayList&lt;&gt;();&#10;        int maxDiameter = -1;&#10;        for (User user : userRepository.findAll()) {&#10;            if (!visitedGlobal.contains(user)) {&#10;                Set&lt;User&gt; currentCommunitySet = new HashSet&lt;&gt;();&#10;                Algorithms.dfs(user, currentCommunitySet); // Găsește toți membrii&#10;                visitedGlobal.addAll(currentCommunitySet);&#10;                List&lt;User&gt; currentCommunityList = new ArrayList&lt;&gt;(currentCommunitySet);&#10;                int currentDiameter = Algorithms.getDiameter(currentCommunityList);&#10;                if (currentDiameter &gt; maxDiameter) {&#10;                    maxDiameter = currentDiameter;&#10;                    bestCommunity = currentCommunityList;&#10;                }&#10;            }&#10;        }&#10;        System.out.println(&quot;Diametrul maxim găsit: &quot; + maxDiameter);&#10;        return bestCommunity;&#10;    }&#10;&#10;    // CARD operations&#10;    /**&#10;     * Create a card (flock) that can contain ducks and compute their average performance.&#10;     *&#10;     * @param numeCard card name&#10;     * @return created {@link Card}&#10;     */&#10;    public Card createCard(String numeCard){&#10;        Card persisted;&#10;        if (cardRepository != null) {&#10;            // persist first to obtain DB-generated id&#10;            persisted = cardRepository.save(new Card(-1, numeCard));&#10;        } else {&#10;            // fallback to in-memory id assignment&#10;            int newId = cards.keySet().stream().mapToInt(Integer::intValue).max().orElse(0) + 1;&#10;            persisted = new Card(newId, numeCard);&#10;        }&#10;        cards.put(persisted.getId(), persisted);&#10;        return persisted;&#10;    }&#10;&#10;    /**&#10;     * @return view of all created cards&#10;     */&#10;    public Collection&lt;Card&gt; getAllCards(){&#10;        return cards.values();&#10;    }&#10;&#10;    /**&#10;     * Add a duck to a card by their ids.&#10;     *&#10;     * @param cardId card id&#10;     * @param duckId duck user id&#10;     */&#10;    public void addDuckToCard(int cardId, int duckId){&#10;        Card c = cards.get(cardId);&#10;        if(c==null) throw new RepoError(&quot;Card not found&quot;);&#10;        User u = userRepository.findOne(duckId);&#10;        if(!(u instanceof Duck)) throw new RepoError(&quot;User is not a duck or not found&quot;);&#10;        c.addDuck((Duck) u);&#10;        if(cardRepository != null) {&#10;            cardRepository.addDuck(cardId, duckId);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Remove a duck from a card by their ids.&#10;     *&#10;     * @param cardId card id&#10;     * @param duckId duck user id&#10;     */&#10;    public void removeDuckFromCard(int cardId, int duckId){&#10;        Card c = cards.get(cardId);&#10;        if(c==null) throw new RepoError(&quot;Card not found&quot;);&#10;        User u = userRepository.findOne(duckId);&#10;        if(!(u instanceof Duck)) throw new RepoError(&quot;User is not a duck or not found&quot;);&#10;        c.removeDuck((Duck) u);&#10;        if(cardRepository != null) {&#10;            cardRepository.removeDuck(cardId, duckId);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Compute the average performance value for a card.&#10;     *&#10;     * @param cardId card id&#10;     * @return average performance&#10;     */&#10;    public double getCardPerformantaMedie(int cardId){&#10;        Card c = cards.get(cardId);&#10;        if(c==null) throw new RepoError(&quot;Card not found&quot;);&#10;        return c.getPerformantaMedie();&#10;    }&#10;&#10;    // EVENT operations using repository&#10;    /**&#10;     * Create and store a race event with a specific lane count.&#10;     *&#10;     * @param name  event name&#10;     * @param lanes number of lanes (M)&#10;     * @return created {@link RaceEvent} with a DB-generated id&#10;     */&#10;    public RaceEvent createRaceEvent(String name, int lanes){&#10;        // temporary id; PostgresEventRepository should ignore/use its own sequence&#10;        RaceEvent re = new RaceEvent(-1, name, lanes);&#10;        eventRepository.save(re);&#10;        return re;&#10;    }&#10;&#10;    /**&#10;     * @return all events stored in the repository&#10;     */&#10;    public Iterable&lt;Event&gt; getAllEvents(){ return eventRepository.findAll(); }&#10;&#10;    /**&#10;     * Subscribe a user to an event by ids.&#10;     *&#10;     * @param eventId event id&#10;     * @param userId  user id&#10;     */&#10;    public void subscribeToEvent(int eventId, int userId){&#10;        Event e = eventRepository.findOne(eventId);&#10;        if(e==null) throw new RepoError(&quot;Event not found&quot;);&#10;        User u = userRepository.findOne(userId);&#10;        if(u==null) throw new RepoError(&quot;User not found&quot;);&#10;        e.subscribe(u);&#10;        if(eventRepository instanceof PostgresEventRepository pe){&#10;            pe.addSubscriber(eventId, userId);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Unsubscribe a user from an event (no-op if user or event does not exist).&#10;     *&#10;     * @param eventId event id&#10;     * @param userId  user id&#10;     */&#10;    public void unsubscribeFromEvent(int eventId, int userId){&#10;        Event e = eventRepository.findOne(eventId);&#10;        if(e==null) throw new RepoError(&quot;Event not found&quot;);&#10;        User u = userRepository.findOne(userId);&#10;        if(u!=null) {&#10;            e.unsubscribe(u);&#10;            if(eventRepository instanceof PostgresEventRepository pe){&#10;                pe.removeSubscriber(eventId, userId);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Run a race event identified by id. It gathers all users that are both Duck and Inotator,&#10;     * selects up to M participants, runs the optimizer and returns a textual report.&#10;     *&#10;     * @param eventId the race event id&#10;     * @return list of report lines (one per lane + minimal total time)&#10;     */&#10;    public List&lt;String&gt; runRace(int eventId){&#10;        Event ev = eventRepository.findOne(eventId);&#10;        if(!(ev instanceof RaceEvent)) throw new RepoError(&quot;Event is not a race&quot;);&#10;        RaceEvent re = (RaceEvent) ev;&#10;        List&lt;Duck&gt; allDucks = new ArrayList&lt;&gt;();&#10;        for (User u : userRepository.findAll()) if(u instanceof Duck &amp;&amp; u instanceof Inotator) allDucks.add((Duck) u);&#10;        re.selectParticipants(allDucks);&#10;        List&lt;String&gt; report = re.runRaceAndReport();&#10;        if(eventRepository instanceof PostgresEventRepository pe){&#10;            pe.addNotification(eventId, &quot;Race finished. Results available.&quot;);&#10;        }&#10;        return report;&#10;    }&#10;&#10;    /**&#10;     * Configure lane distances for a race event.&#10;     *&#10;     * @param eventId   race event id&#10;     * @param distances per-lane distances (exactly M values)&#10;     */&#10;    public void setRaceDistances(int eventId, double[] distances){&#10;        Event ev = eventRepository.findOne(eventId);&#10;        if(!(ev instanceof RaceEvent)) throw new errors.RepoError(&quot;Event is not a race&quot;);&#10;        ((RaceEvent) ev).setDistances(distances);&#10;    }&#10;&#10;    /**&#10;     * Get the notifications received by a specific user.&#10;     *&#10;     * @param userId id of the user&#10;     * @return unmodifiable list of messages&#10;     * @throws RepoError if the user is not found&#10;     */&#10;    public List&lt;String&gt; getUserNotifications(int userId){&#10;        User u = userRepository.findOne(userId);&#10;        if(u==null) throw new RepoError(&quot;User not found&quot;);&#10;        return u.getNotifications();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package service;&#10;&#10;import domain.*;&#10;import errors.RepoError;&#10;import errors.ValidationError;&#10;import repo.EventRepository;&#10;import repo.UserRepository;&#10;import repo.PostgresUserRepository; // added&#10;import repo.PostgresEventRepository;&#10;import repo.CardRepository;&#10;&#10;import util.Algorithms;&#10;import validator.ValidationStrategy;&#10;&#10;import java.util.*;&#10;&#10;/**&#10; * Service layer that orchestrates repository access, validation and business&#10; * operations for the social network domain.&#10; */&#10;public class NetworkService {&#10;    private UserRepository userRepository;&#10;    private EventRepository eventRepository;&#10;    private ValidationStrategy&lt;Persoana&gt; persoanaValidator;&#10;    private ValidationStrategy&lt;Duck&gt; duckValidator;&#10;    private final Map&lt;Integer, Card&gt; cards = new HashMap&lt;&gt;();&#10;    private final CardRepository cardRepository;&#10;&#10;    /**&#10;     * Construct the NetworkService with required dependencies.&#10;     *&#10;     * @param userRepository repository for users&#10;     * @param eventRepository repository for events&#10;     * @param persoanaValidator validator for Persoana instances&#10;     * @param duckValidator validator for Duck instances&#10;     * @param cardRepository repository for cards&#10;     */&#10;    public NetworkService(UserRepository userRepository, EventRepository eventRepository, ValidationStrategy&lt;Persoana&gt; persoanaValidator, ValidationStrategy&lt;Duck&gt; duckValidator, CardRepository cardRepository) {&#10;        this.userRepository = userRepository;&#10;        this.eventRepository = eventRepository;&#10;        this.persoanaValidator = persoanaValidator;&#10;        this.duckValidator = duckValidator;&#10;        this.cardRepository = cardRepository;&#10;        if(cardRepository != null){&#10;            for (Card card : cardRepository.findAll()) {&#10;                cards.put(card.getId(), card);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Add a new user to the network after validating it.&#10;     *&#10;     * @param user the user to add (Persoana or Duck)&#10;     * @return the saved user&#10;     * @throws ValidationError when validation fails&#10;     * @throws RepoError when repository rejects the save (e.g. duplicate id)&#10;     */&#10;    public User addUser(User user) throws ValidationError, RepoError {&#10;        if(user instanceof Persoana){&#10;            persoanaValidator.validate((Persoana) user);&#10;        }&#10;        else if(user instanceof Duck){&#10;            duckValidator.validate((Duck) user);&#10;        }&#10;        else{&#10;            throw new ValidationError(&quot;Unknown user type&quot;);&#10;        }&#10;        return userRepository.save(user);&#10;    }&#10;&#10;    /**&#10;     * Remove a user by id and clean up references from other users' friend lists.&#10;     * Also removes a duck from all cards where it appears.&#10;     *&#10;     * @param id the id of the user to remove&#10;     * @return the removed user&#10;     * @throws RepoError when the user does not exist&#10;     */&#10;    public User removeUser(Integer id){&#10;        User userToRemove=userRepository.delete(id);&#10;        if(userToRemove==null){&#10;            throw new RepoError(&quot;User with id &quot;+id+&quot; not found&quot;);&#10;        }&#10;        for (User u: userRepository.findAll()) {&#10;            u.removeFriend(userToRemove);&#10;        }&#10;        // also remove from cards if it's a Duck&#10;        if (userToRemove instanceof Duck) {&#10;            Duck d = (Duck) userToRemove;&#10;            for (Card c : cards.values()) {&#10;                c.removeDuck(d);&#10;            }&#10;            if (cardRepository != null) {&#10;                cardRepository.removeDuckFromAll(d.getId());&#10;            }&#10;        }&#10;        return userToRemove;&#10;    }&#10;&#10;    /**&#10;     * Create a mutual friendship between two users identified by their ids.&#10;     *&#10;     * @param id1 first user's id&#10;     * @param id2 second user's id&#10;     * @throws RepoError when either user is not found&#10;     */&#10;    public void addFriendship(Integer id1, Integer id2){&#10;        User user1=userRepository.findOne(id1);&#10;        User user2=userRepository.findOne(id2);&#10;        if(user1==null){&#10;            throw new RepoError(&quot;User with id &quot;+id1+&quot; not found&quot;);&#10;        }&#10;        if(user2==null){&#10;            throw new RepoError(&quot;User with id &quot;+id2+&quot; not found&quot;);&#10;        }&#10;        user1.addFriend(user2);&#10;        user2.addFriend(user1);&#10;        if(userRepository instanceof PostgresUserRepository pr){&#10;            pr.saveFriendship(id1, id2);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Remove a mutual friendship between two users (if present).&#10;     *&#10;     * @param id1 first user's id&#10;     * @param id2 second user's id&#10;     */&#10;    public void removeFriendship(Integer id1, Integer id2){&#10;        User user1=userRepository.findOne(id1);&#10;        User user2=userRepository.findOne(id2);&#10;        if(user1!=null){&#10;            user1.removeFriend(user2);&#10;        }&#10;        if(user2!=null){&#10;            user2.removeFriend(user1);&#10;        }&#10;        if(userRepository instanceof PostgresUserRepository pr){&#10;            pr.deleteFriendship(id1, id2);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Retrieve all users in the network.&#10;     *&#10;     * @return iterable of all users&#10;     */&#10;    public Iterable&lt;User&gt; getAllUsers(){&#10;        return userRepository.findAll();&#10;    }&#10;&#10;    /**&#10;     * Compute the number of connected components (communities) in the network.&#10;     *&#10;     * @return number of communities&#10;     */&#10;    public int getNumberOfCommunities(){&#10;        Set&lt;User&gt; visited=new HashSet&lt;&gt;();&#10;        int communities=0;&#10;        for (User user: userRepository.findAll()) {&#10;            if(!visited.contains(user)){&#10;                communities++;&#10;                Algorithms.dfs(user, visited);&#10;            }&#10;        }&#10;        return communities;&#10;    }&#10;&#10;    /**&#10;     * Find the community with the largest diameter (most social community).&#10;     * The method returns the list of users in the community with the maximum&#10;     * shortest-path diameter.&#10;     *&#10;     * @return list of users forming the most social community&#10;     */&#10;    public List&lt;User&gt; getMostSocialCommunity() {&#10;        Set&lt;User&gt; visitedGlobal = new HashSet&lt;&gt;();&#10;        List&lt;User&gt; bestCommunity = new ArrayList&lt;&gt;();&#10;        int maxDiameter = -1;&#10;        for (User user : userRepository.findAll()) {&#10;            if (!visitedGlobal.contains(user)) {&#10;                Set&lt;User&gt; currentCommunitySet = new HashSet&lt;&gt;();&#10;                Algorithms.dfs(user, currentCommunitySet); // Găsește toți membrii&#10;                visitedGlobal.addAll(currentCommunitySet);&#10;                List&lt;User&gt; currentCommunityList = new ArrayList&lt;&gt;(currentCommunitySet);&#10;                int currentDiameter = Algorithms.getDiameter(currentCommunityList);&#10;                if (currentDiameter &gt; maxDiameter) {&#10;                    maxDiameter = currentDiameter;&#10;                    bestCommunity = currentCommunityList;&#10;                }&#10;            }&#10;        }&#10;        System.out.println(&quot;Diametrul maxim găsit: &quot; + maxDiameter);&#10;        return bestCommunity;&#10;    }&#10;&#10;    // CARD operations&#10;    /**&#10;     * Create a card (flock) that can contain ducks and compute their average performance.&#10;     *&#10;     * @param numeCard card name&#10;     * @return created {@link Card}&#10;     */&#10;    public Card createCard(String numeCard){&#10;        Card persisted;&#10;        if (cardRepository != null) {&#10;            // persist first to obtain DB-generated id&#10;            persisted = cardRepository.save(new Card(-1, numeCard));&#10;        } else {&#10;            // fallback to in-memory id assignment&#10;            int newId = cards.keySet().stream().mapToInt(Integer::intValue).max().orElse(0) + 1;&#10;            persisted = new Card(newId, numeCard);&#10;        }&#10;        cards.put(persisted.getId(), persisted);&#10;        return persisted;&#10;    }&#10;&#10;    /**&#10;     * @return view of all created cards&#10;     */&#10;    public Collection&lt;Card&gt; getAllCards(){&#10;        return cards.values();&#10;    }&#10;&#10;    /**&#10;     * Add a duck to a card by their ids.&#10;     *&#10;     * @param cardId card id&#10;     * @param duckId duck user id&#10;     */&#10;    public void addDuckToCard(int cardId, int duckId){&#10;        Card c = cards.get(cardId);&#10;        if(c==null) throw new RepoError(&quot;Card not found&quot;);&#10;        User u = userRepository.findOne(duckId);&#10;        if(!(u instanceof Duck)) throw new RepoError(&quot;User is not a duck or not found&quot;);&#10;        c.addDuck((Duck) u);&#10;        if(cardRepository != null) {&#10;            cardRepository.addDuck(cardId, duckId);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Remove a duck from a card by their ids.&#10;     *&#10;     * @param cardId card id&#10;     * @param duckId duck user id&#10;     */&#10;    public void removeDuckFromCard(int cardId, int duckId){&#10;        Card c = cards.get(cardId);&#10;        if(c==null) throw new RepoError(&quot;Card not found&quot;);&#10;        User u = userRepository.findOne(duckId);&#10;        if(!(u instanceof Duck)) throw new RepoError(&quot;User is not a duck or not found&quot;);&#10;        c.removeDuck((Duck) u);&#10;        if(cardRepository != null) {&#10;            cardRepository.removeDuck(cardId, duckId);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Compute the average performance value for a card.&#10;     *&#10;     * @param cardId card id&#10;     * @return average performance&#10;     */&#10;    public double getCardPerformantaMedie(int cardId){&#10;        Card c = cards.get(cardId);&#10;        if(c==null) throw new RepoError(&quot;Card not found&quot;);&#10;        return c.getPerformantaMedie();&#10;    }&#10;&#10;    // EVENT operations using repository&#10;    /**&#10;     * Create and store a race event with a specific lane count.&#10;     *&#10;     * @param name  event name&#10;     * @param lanes number of lanes (M)&#10;     * @return created {@link RaceEvent} with a DB-generated id&#10;     */&#10;    public RaceEvent createRaceEvent(String name, int lanes){&#10;        // temporary id; PostgresEventRepository should ignore/use its own sequence&#10;        RaceEvent re = new RaceEvent(-1, name, lanes);&#10;        eventRepository.save(re);&#10;        return re;&#10;    }&#10;&#10;    /**&#10;     * @return all events stored in the repository&#10;     */&#10;    public Iterable&lt;Event&gt; getAllEvents(){ return eventRepository.findAll(); }&#10;&#10;    /**&#10;     * Subscribe a user to an event by ids.&#10;     *&#10;     * @param eventId event id&#10;     * @param userId  user id&#10;     */&#10;    public void subscribeToEvent(int eventId, int userId){&#10;        Event e = eventRepository.findOne(eventId);&#10;        if(e==null) throw new RepoError(&quot;Event not found&quot;);&#10;        User u = userRepository.findOne(userId);&#10;        if(u==null) throw new RepoError(&quot;User not found&quot;);&#10;        e.subscribe(u);&#10;        if(eventRepository instanceof PostgresEventRepository pe){&#10;            pe.addSubscriber(eventId, userId);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Unsubscribe a user from an event (no-op if user or event does not exist).&#10;     *&#10;     * @param eventId event id&#10;     * @param userId  user id&#10;     */&#10;    public void unsubscribeFromEvent(int eventId, int userId){&#10;        Event e = eventRepository.findOne(eventId);&#10;        if(e==null) throw new RepoError(&quot;Event not found&quot;);&#10;        User u = userRepository.findOne(userId);&#10;        if(u!=null) {&#10;            e.unsubscribe(u);&#10;            if(eventRepository instanceof PostgresEventRepository pe){&#10;                pe.removeSubscriber(eventId, userId);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Run a race event identified by id. It gathers all users that are both Duck and Inotator,&#10;     * selects up to M participants, runs the optimizer and returns a textual report.&#10;     *&#10;     * @param eventId the race event id&#10;     * @return list of report lines (one per lane + minimal total time)&#10;     */&#10;    public List&lt;String&gt; runRace(int eventId){&#10;        Event ev = eventRepository.findOne(eventId);&#10;        if(!(ev instanceof RaceEvent)) throw new RepoError(&quot;Event is not a race&quot;);&#10;        RaceEvent re = (RaceEvent) ev;&#10;        List&lt;Duck&gt; allDucks = new ArrayList&lt;&gt;();&#10;        for (User u : userRepository.findAll()) if(u instanceof Duck &amp;&amp; u instanceof Inotator) allDucks.add((Duck) u);&#10;        re.selectParticipants(allDucks);&#10;        List&lt;String&gt; report = re.runRaceAndReport();&#10;        if(eventRepository instanceof PostgresEventRepository pe){&#10;            pe.addNotification(eventId, &quot;Race finished. Results available.&quot;);&#10;        }&#10;        return report;&#10;    }&#10;&#10;    /**&#10;     * Configure lane distances for a race event.&#10;     *&#10;     * @param eventId   race event id&#10;     * @param distances per-lane distances (exactly M values)&#10;     */&#10;    public void setRaceDistances(int eventId, double[] distances){&#10;        Event ev = eventRepository.findOne(eventId);&#10;        if(!(ev instanceof RaceEvent)) throw new errors.RepoError(&quot;Event is not a race&quot;);&#10;        ((RaceEvent) ev).setDistances(distances);&#10;    }&#10;&#10;    /**&#10;     * Get the notifications received by a specific user.&#10;     *&#10;     * @param userId id of the user&#10;     * @return unmodifiable list of messages&#10;     * @throws RepoError if the user is not found&#10;     */&#10;    public List&lt;String&gt; getUserNotifications(int userId){&#10;        User u = userRepository.findOne(userId);&#10;        if(u==null) throw new RepoError(&quot;User not found&quot;);&#10;        return u.getNotifications();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>