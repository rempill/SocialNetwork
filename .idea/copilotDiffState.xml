<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/domain/Message.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/domain/Message.java" />
              <option name="originalContent" value="package domain;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.ArrayList;&#10;import java.util.Collections;&#10;import java.util.List;&#10;&#10;/**&#10; * Represents a message exchanged between users. Supports multi-recipient and replies.&#10; */&#10;public class Message {&#10;    private final int id;&#10;    private final User from;&#10;    private final List&lt;User&gt; to;&#10;    private final String message;&#10;    private final LocalDateTime createdAt;&#10;    private final Message replyTo;&#10;&#10;    public Message(int id, User from, List&lt;User&gt; to, String message, LocalDateTime createdAt) {&#10;        this(id, from, to, message, createdAt, null);&#10;    }&#10;&#10;    public Message(int id, User from, List&lt;User&gt; to, String message, LocalDateTime createdAt, Message replyTo) {&#10;        if (from == null) throw new IllegalArgumentException(&quot;sender missing&quot;);&#10;        if (to == null || to.isEmpty()) throw new IllegalArgumentException(&quot;recipients missing&quot;);&#10;        if (message == null || message.isBlank()) throw new IllegalArgumentException(&quot;text missing&quot;);&#10;        this.id = id;&#10;        this.from = from;&#10;        this.to = new ArrayList&lt;&gt;(to);&#10;        this.message = message;&#10;        this.createdAt = createdAt != null ? createdAt : LocalDateTime.now();&#10;        this.replyTo = replyTo;&#10;    }&#10;&#10;    public int getId() {&#10;        return id;&#10;    }&#10;&#10;    public User getFrom() {&#10;        return from;&#10;    }&#10;&#10;    public List&lt;User&gt; getTo() {&#10;        return Collections.unmodifiableList(to);&#10;    }&#10;&#10;    public String getMessage() {&#10;        return message;&#10;    }&#10;&#10;    public LocalDateTime getCreatedAt() {&#10;        return createdAt;&#10;    }&#10;&#10;    public Message getReplyTo() {&#10;        return replyTo;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package domain;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.ArrayList;&#10;import java.util.Collections;&#10;import java.util.List;&#10;&#10;/**&#10; * Represents a message exchanged between users. Supports multi-recipient and replies.&#10; */&#10;public class Message {&#10;    private final int id;&#10;    private final User from;&#10;    private final List&lt;User&gt; to;&#10;    private final String message;&#10;    private final LocalDateTime createdAt;&#10;    private final Message replyTo;&#10;&#10;    public Message(int id, User from, List&lt;User&gt; to, String message, LocalDateTime createdAt) {&#10;        this(id, from, to, message, createdAt, null);&#10;    }&#10;&#10;    public Message(int id, User from, List&lt;User&gt; to, String message, LocalDateTime createdAt, Message replyTo) {&#10;        if (from == null) throw new IllegalArgumentException(&quot;sender missing&quot;);&#10;        if (to == null || to.isEmpty()) throw new IllegalArgumentException(&quot;recipients missing&quot;);&#10;        if (message == null || message.isBlank()) throw new IllegalArgumentException(&quot;text missing&quot;);&#10;        this.id = id;&#10;        this.from = from;&#10;        this.to = new ArrayList&lt;&gt;(to);&#10;        this.message = message;&#10;        this.createdAt = createdAt != null ? createdAt : LocalDateTime.now();&#10;        this.replyTo = replyTo;&#10;    }&#10;&#10;    public int getId() {&#10;        return id;&#10;    }&#10;&#10;    public User getFrom() {&#10;        return from;&#10;    }&#10;&#10;    public List&lt;User&gt; getTo() {&#10;        return Collections.unmodifiableList(to);&#10;    }&#10;&#10;    public String getMessage() {&#10;        return message;&#10;    }&#10;&#10;    public LocalDateTime getCreatedAt() {&#10;        return createdAt;&#10;    }&#10;&#10;    public Message getReplyTo() {&#10;        return replyTo;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/domain/RaceEvent.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/domain/RaceEvent.java" />
              <option name="originalContent" value="package domain;&#10;&#10;import java.util.ArrayList;&#10;import java.util.Comparator;&#10;import java.util.List;&#10;import java.util.stream.Collectors;&#10;&#10;/**&#10; * Special event for swimming ducks. It auto-selects M ducks according to&#10; * simple swimming criteria and simulates the race.&#10; */&#10;public class RaceEvent extends Event {&#10;    private final int lanes; // M&#10;    private final List&lt;Duck&gt; participants = new ArrayList&lt;&gt;();&#10;    private double[] distances; // per-lane distances&#10;&#10;    /**&#10;     * Construct a race event with the specified number of lanes (M). Distances default to 1.0.&#10;     *&#10;     * @param id    event id&#10;     * @param name  event name&#10;     * @param lanes number of lanes (M &gt; 0)&#10;     */&#10;    public RaceEvent(int id, String name, int lanes) {&#10;        super(id, name);&#10;        if(lanes &lt;= 0) throw new IllegalArgumentException(&quot;lanes must be &gt; 0&quot;);&#10;        this.lanes = lanes;&#10;        this.distances = new double[lanes];&#10;        for (int i = 0; i &lt; lanes; i++) this.distances[i] = 1.0; // default&#10;    }&#10;&#10;    /**&#10;     * @return number of lanes (M) in this race&#10;     */&#10;    public int getLanes() { return lanes; }&#10;&#10;    /**&#10;     * @return the currently selected race participants (read-only snapshot semantics)&#10;     */&#10;    public List&lt;Duck&gt; getParticipants() { return participants; }&#10;&#10;    /**&#10;     * @return defensive copy of the configured lane distances&#10;     */&#10;    public double[] getDistances() {&#10;        return distances.clone();&#10;    }&#10;&#10;    /**&#10;     * Set the per-lane distances, must have exactly M entries.&#10;     *&#10;     * @param distances distances per lane&#10;     * @throws IllegalArgumentException if array is null or its length != M&#10;     */&#10;    public void setDistances(double[] distances){&#10;        if(distances == null || distances.length != lanes) throw new IllegalArgumentException(&quot;distances length must be M&quot;);&#10;        this.distances = distances;&#10;    }&#10;&#10;    /**&#10;     * Select up to M participant ducks from the provided list, filtering to swimmers (Inotator)&#10;     * and sorting by speed desc, then endurance desc.&#10;     *&#10;     * @param allDucks candidate ducks (may contain non-swimmers)&#10;     */&#10;    public void selectParticipants(List&lt;Duck&gt; allDucks){&#10;        participants.clear();&#10;        if(allDucks == null) return;&#10;        List&lt;Duck&gt; swimmers = allDucks.stream()&#10;                .filter(d -&gt; d instanceof Inotator)&#10;                .sorted(Comparator.comparingDouble(Duck::getViteza).reversed()&#10;                        .thenComparing(Comparator.comparingDouble(Duck::getRezistenta).reversed()))&#10;                .limit(lanes)&#10;                .collect(Collectors.toList());&#10;        participants.addAll(swimmers);&#10;        notifySubscribers(&quot;Race participants selected: &quot; + participants.stream().map(Duck::getUsername).collect(Collectors.joining(&quot;, &quot;)));&#10;    }&#10;&#10;    /**&#10;     * Run the race using the current participants and configured distances and return a textual&#10;     * report per lane (one line per lane assigned) plus a final line with the minimal total time.&#10;     *&#10;     * @return list of report lines describing per-lane assignments and minimal total time&#10;     */&#10;    public List&lt;String&gt; runRaceAndReport(){&#10;        List&lt;String&gt; report = new ArrayList&lt;&gt;();&#10;        if(participants.isEmpty()){&#10;            report.add(&quot;No participants selected.&quot;);&#10;            return report;&#10;        }&#10;        util.OptimizationStrategy opt = new util.BinarySearchSwimOptimizer();&#10;        util.SolveResult result = opt.computeMinTime(participants.toArray(new Duck[0]), distances);&#10;        Duck[] assignment = result.getAssignments();&#10;        double minimalTime = result.getMinimalTime();&#10;&#10;        for (int i = 0; i &lt; assignment.length; i++) {&#10;            Duck d = assignment[i];&#10;            if (d == null) continue;&#10;            int lane = i + 1;&#10;            double t = (2.0 * distances[i]) / d.getViteza();&#10;            report.add(String.format(&quot;Duck %d on lane %d: t = %.3f s&quot;, d.getId(), lane, t));&#10;        }&#10;        report.add(String.format(&quot;Minimal total time: %.3f s&quot;, minimalTime));&#10;        notifySubscribers(&quot;Race finished. Results available.&quot;);&#10;        return report;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package domain;&#10;&#10;import java.util.ArrayList;&#10;import java.util.Comparator;&#10;import java.util.List;&#10;import java.util.stream.Collectors;&#10;&#10;/**&#10; * Special event for swimming ducks. It auto-selects M ducks according to&#10; * simple swimming criteria and simulates the race.&#10; */&#10;public class RaceEvent extends Event {&#10;    private final int lanes; // M&#10;    private final List&lt;Duck&gt; participants = new ArrayList&lt;&gt;();&#10;    private double[] distances; // per-lane distances&#10;&#10;    /**&#10;     * Construct a race event with the specified number of lanes (M). Distances default to 1.0.&#10;     *&#10;     * @param id    event id&#10;     * @param name  event name&#10;     * @param lanes number of lanes (M &gt; 0)&#10;     */&#10;    public RaceEvent(int id, String name, int lanes) {&#10;        super(id, name);&#10;        if(lanes &lt;= 0) throw new IllegalArgumentException(&quot;lanes must be &gt; 0&quot;);&#10;        this.lanes = lanes;&#10;        this.distances = new double[lanes];&#10;        for (int i = 0; i &lt; lanes; i++) this.distances[i] = 1.0; // default&#10;    }&#10;&#10;    /**&#10;     * @return number of lanes (M) in this race&#10;     */&#10;    public int getLanes() { return lanes; }&#10;&#10;    /**&#10;     * @return the currently selected race participants (read-only snapshot semantics)&#10;     */&#10;    public List&lt;Duck&gt; getParticipants() { return participants; }&#10;&#10;    /**&#10;     * @return defensive copy of the configured lane distances&#10;     */&#10;    public double[] getDistances() {&#10;        return distances.clone();&#10;    }&#10;&#10;    /**&#10;     * Set the per-lane distances, must have exactly M entries.&#10;     *&#10;     * @param distances distances per lane&#10;     * @throws IllegalArgumentException if array is null or its length != M&#10;     */&#10;    public void setDistances(double[] distances){&#10;        if(distances == null || distances.length != lanes) throw new IllegalArgumentException(&quot;distances length must be M&quot;);&#10;        this.distances = distances;&#10;    }&#10;&#10;    /**&#10;     * Select up to M participant ducks from the provided list, filtering to swimmers (Inotator)&#10;     * and sorting by speed desc, then endurance desc.&#10;     *&#10;     * @param allDucks candidate ducks (may contain non-swimmers)&#10;     */&#10;    public void selectParticipants(List&lt;Duck&gt; allDucks){&#10;        participants.clear();&#10;        if(allDucks == null) return;&#10;        List&lt;Duck&gt; swimmers = allDucks.stream()&#10;                .filter(d -&gt; d instanceof Inotator)&#10;                .sorted(Comparator.comparingDouble(Duck::getViteza).reversed()&#10;                        .thenComparing(Comparator.comparingDouble(Duck::getRezistenta).reversed()))&#10;                .limit(lanes)&#10;                .collect(Collectors.toList());&#10;        participants.addAll(swimmers);&#10;        notifySubscribers(&quot;Race participants selected: &quot; + participants.stream().map(Duck::getUsername).collect(Collectors.joining(&quot;, &quot;)));&#10;    }&#10;&#10;    /**&#10;     * Run the race using the current participants and configured distances and return a textual&#10;     * report per lane (one line per lane assigned) plus a final line with the minimal total time.&#10;     *&#10;     * @return list of report lines describing per-lane assignments and minimal total time&#10;     */&#10;    public List&lt;String&gt; runRaceAndReport(){&#10;        List&lt;String&gt; report = new ArrayList&lt;&gt;();&#10;        if(participants.isEmpty()){&#10;            report.add(&quot;No participants selected.&quot;);&#10;            return report;&#10;        }&#10;        util.OptimizationStrategy opt = new util.BinarySearchSwimOptimizer();&#10;        util.SolveResult result = opt.computeMinTime(participants.toArray(new Duck[0]), distances);&#10;        Duck[] assignment = result.getAssignments();&#10;        double minimalTime = result.getMinimalTime();&#10;&#10;        for (int i = 0; i &lt; assignment.length; i++) {&#10;            Duck d = assignment[i];&#10;            if (d == null) continue;&#10;            int lane = i + 1;&#10;            double t = (2.0 * distances[i]) / d.getViteza();&#10;            report.add(String.format(&quot;Duck %d on lane %d: t = %.3f s&quot;, d.getId(), lane, t));&#10;        }&#10;        report.add(String.format(&quot;Minimal total time: %.3f s&quot;, minimalTime));&#10;        notifySubscribers(&quot;Race finished. Results available.&quot;);&#10;        return report;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/repo/CardRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/repo/CardRepository.java" />
              <option name="originalContent" value="package repo;&#10;&#10;import domain.Card;&#10;&#10;/**&#10; * Repository specialization for {@link Card} aggregates.&#10; */&#10;public interface CardRepository extends Repository&lt;Integer, Card&gt; {&#10;    /**&#10;     * Persist the association between a card and a duck member.&#10;     */&#10;    void addDuck(int cardId, int duckId);&#10;&#10;    /**&#10;     * Remove the association between a card and a duck member.&#10;     */&#10;    void removeDuck(int cardId, int duckId);&#10;&#10;    /**&#10;     * Remove the association between all cards and a duck member.&#10;     */&#10;    void removeDuckFromAll(int duckId);&#10;}" />
              <option name="updatedContent" value="package repo;&#10;&#10;import domain.Card;&#10;&#10;/**&#10; * Repository specialization for {@link Card} aggregates.&#10; */&#10;public interface CardRepository extends Repository&lt;Integer, Card&gt; {&#10;    /**&#10;     * Persist the association between a card and a duck member.&#10;     */&#10;    void addDuck(int cardId, int duckId);&#10;&#10;    /**&#10;     * Remove the association between a card and a duck member.&#10;     */&#10;    void removeDuck(int cardId, int duckId);&#10;&#10;    /**&#10;     * Remove the association between all cards and a duck member.&#10;     */&#10;    void removeDuckFromAll(int duckId);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/repo/PostgresMessageRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/repo/PostgresMessageRepository.java" />
              <option name="originalContent" value="package repo;&#10;&#10;import domain.Message;&#10;import domain.User;&#10;import errors.RepoError;&#10;&#10;import java.sql.*;&#10;import java.util.ArrayList;&#10;import java.util.HashMap;&#10;import java.util.List;&#10;import java.util.Map;&#10;&#10;/**&#10; * JDBC repository for messages.&#10; */&#10;public class PostgresMessageRepository implements MessageRepository {&#10;    private final String url;&#10;    private final String user;&#10;    private final String password;&#10;    private final UserRepository userRepository;&#10;    private Connection connection;&#10;&#10;    public PostgresMessageRepository(String url, String user, String password, UserRepository userRepository) {&#10;        this.url = url;&#10;        this.user = user;&#10;        this.password = password;&#10;        this.userRepository = userRepository;&#10;        try {&#10;            this.connection = DriverManager.getConnection(url, user, password);&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB connection error: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public Message findOne(Integer id) {&#10;        if (id == null) {&#10;            throw new IllegalArgumentException(&quot;id null&quot;);&#10;        }&#10;        String sql = &quot;SELECT sender_id, text, created_at, reply_to FROM messages WHERE id = ?&quot;;&#10;        try (PreparedStatement ps = connection.prepareStatement(sql)) {&#10;            ps.setInt(1, id);&#10;            try (ResultSet rs = ps.executeQuery()) {&#10;                if (!rs.next()) {&#10;                    return null;&#10;                }&#10;                User from = userRepository.findOne(rs.getInt(&quot;sender_id&quot;));&#10;                List&lt;User&gt; recipients = loadRecipients(id);&#10;                Message reply = rs.getObject(&quot;reply_to&quot;) != null ? findOne(rs.getInt(&quot;reply_to&quot;)) : null;&#10;                return new Message(id, from, recipients, rs.getString(&quot;text&quot;),&#10;                        rs.getTimestamp(&quot;created_at&quot;).toLocalDateTime(), reply);&#10;            }&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB findOne error: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    private List&lt;User&gt; loadRecipients(int messageId) throws SQLException {&#10;        String sql = &quot;SELECT recipient_id FROM message_recipients WHERE message_id = ?&quot;;&#10;        List&lt;User&gt; recipients = new ArrayList&lt;&gt;();&#10;        try (PreparedStatement ps = connection.prepareStatement(sql)) {&#10;            ps.setInt(1, messageId);&#10;            try (ResultSet rs = ps.executeQuery()) {&#10;                while (rs.next()) {&#10;                    User u = userRepository.findOne(rs.getInt(&quot;recipient_id&quot;));&#10;                    if (u != null) {&#10;                        recipients.add(u);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        return recipients;&#10;    }&#10;&#10;    @Override&#10;    public Iterable&lt;Message&gt; findAll() {&#10;        throw new UnsupportedOperationException(&quot;Use conversation queries&quot;);&#10;    }&#10;&#10;    @Override&#10;    public Message save(Message entity) {&#10;        if (entity == null) throw new IllegalArgumentException(&quot;message null&quot;);&#10;        String sql = &quot;INSERT INTO messages(sender_id, text, created_at, reply_to) VALUES(?,?,?,?) RETURNING id&quot;;&#10;        try (PreparedStatement ps = connection.prepareStatement(sql)) {&#10;            ps.setInt(1, entity.getFrom().getId());&#10;            ps.setString(2, entity.getMessage());&#10;            ps.setTimestamp(3, Timestamp.valueOf(entity.getCreatedAt()));&#10;            if (entity.getReplyTo() != null) {&#10;                ps.setInt(4, entity.getReplyTo().getId());&#10;            } else {&#10;                ps.setNull(4, Types.INTEGER);&#10;            }&#10;            try (ResultSet rs = ps.executeQuery()) {&#10;                if (!rs.next()) {&#10;                    throw new RepoError(&quot;Failed to save message&quot;);&#10;                }&#10;                int id = rs.getInt(1);&#10;                insertRecipients(id, entity.getTo());&#10;                return new Message(id, entity.getFrom(), entity.getTo(), entity.getMessage(), entity.getCreatedAt(), entity.getReplyTo());&#10;            }&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB save error: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public Message delete(Integer id) {&#10;        throw new UnsupportedOperationException(&quot;Delete not supported&quot;);&#10;    }&#10;&#10;    @Override&#10;    public List&lt;Message&gt; findConversation(int userId, int otherUserId) {&#10;        String sql = &quot;SELECT m.id, m.sender_id, m.text, m.created_at, m.reply_to &quot; +&#10;                &quot;FROM messages m &quot; +&#10;                &quot;JOIN message_recipients r ON m.id = r.message_id &quot; +&#10;                &quot;WHERE (m.sender_id = ? AND r.recipient_id = ?) OR (m.sender_id = ? AND r.recipient_id = ?) &quot; +&#10;                &quot;ORDER BY m.created_at&quot;;&#10;        try (PreparedStatement ps = connection.prepareStatement(sql)) {&#10;            ps.setInt(1, userId);&#10;            ps.setInt(2, otherUserId);&#10;            ps.setInt(3, otherUserId);&#10;            ps.setInt(4, userId);&#10;            try (ResultSet rs = ps.executeQuery()) {&#10;                List&lt;Message&gt; messages = new ArrayList&lt;&gt;();&#10;                Map&lt;Integer, Message&gt; cache = new HashMap&lt;&gt;();&#10;                while (rs.next()) {&#10;                    int id = rs.getInt(&quot;id&quot;);&#10;                    User from = userRepository.findOne(rs.getInt(&quot;sender_id&quot;));&#10;                    List&lt;User&gt; recipients = loadRecipients(id);&#10;                    Integer replyToId = rs.getObject(&quot;reply_to&quot;) != null ? rs.getInt(&quot;reply_to&quot;) : null;&#10;                    Message reply = replyToId != null ? cache.computeIfAbsent(replyToId, this::findOne) : null;&#10;                    Message m = new Message(id, from, recipients, rs.getString(&quot;text&quot;),&#10;                            rs.getTimestamp(&quot;created_at&quot;).toLocalDateTime(), reply);&#10;                    cache.put(id, m);&#10;                    messages.add(m);&#10;                }&#10;                return messages;&#10;            }&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB conversation error: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public Message saveReply(Message reply) {&#10;        return save(reply);&#10;    }&#10;&#10;    private void insertRecipients(int messageId, List&lt;User&gt; recipients) throws SQLException {&#10;        String sql = &quot;INSERT INTO message_recipients(message_id, recipient_id) VALUES(?,?)&quot;;&#10;        try (PreparedStatement ps = connection.prepareStatement(sql)) {&#10;            for (User to : recipients) {&#10;                ps.setInt(1, messageId);&#10;                ps.setInt(2, to.getId());&#10;                ps.addBatch();&#10;            }&#10;            ps.executeBatch();&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package repo;&#10;&#10;import domain.Message;&#10;import domain.User;&#10;import errors.RepoError;&#10;&#10;import java.sql.*;&#10;import java.util.ArrayList;&#10;import java.util.HashMap;&#10;import java.util.List;&#10;import java.util.Map;&#10;&#10;/**&#10; * JDBC repository for messages.&#10; */&#10;public class PostgresMessageRepository implements MessageRepository {&#10;    private final String url;&#10;    private final String user;&#10;    private final String password;&#10;    private final UserRepository userRepository;&#10;    private Connection connection;&#10;&#10;    public PostgresMessageRepository(String url, String user, String password, UserRepository userRepository) {&#10;        this.url = url;&#10;        this.user = user;&#10;        this.password = password;&#10;        this.userRepository = userRepository;&#10;        try {&#10;            this.connection = DriverManager.getConnection(url, user, password);&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB connection error: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public Message findOne(Integer id) {&#10;        if (id == null) {&#10;            throw new IllegalArgumentException(&quot;id null&quot;);&#10;        }&#10;        String sql = &quot;SELECT sender_id, text, created_at, reply_to FROM messages WHERE id = ?&quot;;&#10;        try (PreparedStatement ps = connection.prepareStatement(sql)) {&#10;            ps.setInt(1, id);&#10;            try (ResultSet rs = ps.executeQuery()) {&#10;                if (!rs.next()) {&#10;                    return null;&#10;                }&#10;                User from = userRepository.findOne(rs.getInt(&quot;sender_id&quot;));&#10;                List&lt;User&gt; recipients = loadRecipients(id);&#10;                Message reply = rs.getObject(&quot;reply_to&quot;) != null ? findOne(rs.getInt(&quot;reply_to&quot;)) : null;&#10;                return new Message(id, from, recipients, rs.getString(&quot;text&quot;),&#10;                        rs.getTimestamp(&quot;created_at&quot;).toLocalDateTime(), reply);&#10;            }&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB findOne error: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    private List&lt;User&gt; loadRecipients(int messageId) throws SQLException {&#10;        String sql = &quot;SELECT recipient_id FROM message_recipients WHERE message_id = ?&quot;;&#10;        List&lt;User&gt; recipients = new ArrayList&lt;&gt;();&#10;        try (PreparedStatement ps = connection.prepareStatement(sql)) {&#10;            ps.setInt(1, messageId);&#10;            try (ResultSet rs = ps.executeQuery()) {&#10;                while (rs.next()) {&#10;                    User u = userRepository.findOne(rs.getInt(&quot;recipient_id&quot;));&#10;                    if (u != null) {&#10;                        recipients.add(u);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        return recipients;&#10;    }&#10;&#10;    @Override&#10;    public Iterable&lt;Message&gt; findAll() {&#10;        throw new UnsupportedOperationException(&quot;Use conversation queries&quot;);&#10;    }&#10;&#10;    @Override&#10;    public Message save(Message entity) {&#10;        if (entity == null) throw new IllegalArgumentException(&quot;message null&quot;);&#10;        String sql = &quot;INSERT INTO messages(sender_id, text, created_at, reply_to) VALUES(?,?,?,?) RETURNING id&quot;;&#10;        try (PreparedStatement ps = connection.prepareStatement(sql)) {&#10;            ps.setInt(1, entity.getFrom().getId());&#10;            ps.setString(2, entity.getMessage());&#10;            ps.setTimestamp(3, Timestamp.valueOf(entity.getCreatedAt()));&#10;            if (entity.getReplyTo() != null) {&#10;                ps.setInt(4, entity.getReplyTo().getId());&#10;            } else {&#10;                ps.setNull(4, Types.INTEGER);&#10;            }&#10;            try (ResultSet rs = ps.executeQuery()) {&#10;                if (!rs.next()) {&#10;                    throw new RepoError(&quot;Failed to save message&quot;);&#10;                }&#10;                int id = rs.getInt(1);&#10;                insertRecipients(id, entity.getTo());&#10;                return new Message(id, entity.getFrom(), entity.getTo(), entity.getMessage(), entity.getCreatedAt(), entity.getReplyTo());&#10;            }&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB save error: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public Message delete(Integer id) {&#10;        throw new UnsupportedOperationException(&quot;Delete not supported&quot;);&#10;    }&#10;&#10;    @Override&#10;    public List&lt;Message&gt; findConversation(int userId, int otherUserId) {&#10;        String sql = &quot;SELECT m.id, m.sender_id, m.text, m.created_at, m.reply_to &quot; +&#10;                &quot;FROM messages m &quot; +&#10;                &quot;JOIN message_recipients r ON m.id = r.message_id &quot; +&#10;                &quot;WHERE (m.sender_id = ? AND r.recipient_id = ?) OR (m.sender_id = ? AND r.recipient_id = ?) &quot; +&#10;                &quot;ORDER BY m.created_at&quot;;&#10;        try (PreparedStatement ps = connection.prepareStatement(sql)) {&#10;            ps.setInt(1, userId);&#10;            ps.setInt(2, otherUserId);&#10;            ps.setInt(3, otherUserId);&#10;            ps.setInt(4, userId);&#10;            try (ResultSet rs = ps.executeQuery()) {&#10;                List&lt;Message&gt; messages = new ArrayList&lt;&gt;();&#10;                Map&lt;Integer, Message&gt; cache = new HashMap&lt;&gt;();&#10;                while (rs.next()) {&#10;                    int id = rs.getInt(&quot;id&quot;);&#10;                    User from = userRepository.findOne(rs.getInt(&quot;sender_id&quot;));&#10;                    List&lt;User&gt; recipients = loadRecipients(id);&#10;                    Integer replyToId = rs.getObject(&quot;reply_to&quot;) != null ? rs.getInt(&quot;reply_to&quot;) : null;&#10;                    Message reply = replyToId != null ? cache.computeIfAbsent(replyToId, this::findOne) : null;&#10;                    Message m = new Message(id, from, recipients, rs.getString(&quot;text&quot;),&#10;                            rs.getTimestamp(&quot;created_at&quot;).toLocalDateTime(), reply);&#10;                    cache.put(id, m);&#10;                    messages.add(m);&#10;                }&#10;                return messages;&#10;            }&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB conversation error: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public Message saveReply(Message reply) {&#10;        return save(reply);&#10;    }&#10;&#10;    private void insertRecipients(int messageId, List&lt;User&gt; recipients) throws SQLException {&#10;        String sql = &quot;INSERT INTO message_recipients(message_id, recipient_id) VALUES(?,?)&quot;;&#10;        try (PreparedStatement ps = connection.prepareStatement(sql)) {&#10;            for (User to : recipients) {&#10;                ps.setInt(1, messageId);&#10;                ps.setInt(2, to.getId());&#10;                ps.addBatch();&#10;            }&#10;            ps.executeBatch();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/repo/PostgresUserRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/repo/PostgresUserRepository.java" />
              <option name="originalContent" value="package repo;&#10;&#10;import domain.*;&#10;import errors.RepoError;&#10;import util.PageResult;&#10;&#10;import java.sql.*;&#10;import java.time.LocalDate;&#10;import java.util.ArrayList;&#10;import java.util.LinkedHashMap;&#10;import java.util.List;&#10;import java.util.Map;&#10;&#10;/**&#10; * JDBC-based repository for persisting {@link User} entities (Persoana and Duck subclasses)&#10; * in a PostgreSQL database. This implementation uses three tables:&#10; *   user_base(id, username, email, password)&#10; *   persoana(id FK -&gt; user_base.id, nume, prenume, ocupatie, data_nasterii, nivel_empatie)&#10; *   duck(id FK -&gt; user_base.id, tip_rata, viteza, rezistenta)&#10; *   user_friend(user_id, friend_id) symmetrical undirected friendship (stored with user_id &lt; friend_id)&#10; *&#10; * Friend relationships now persisted in user_friend; loaded by findAll. findOne currently loads only the base entity.&#10; */&#10;public class PostgresUserRepository implements UserRepository {&#10;    private final String url;&#10;    private final String user;&#10;    private final String password;&#10;    Connection c;&#10;&#10;    public PostgresUserRepository(String url, String user, String password) {&#10;        this.url = url;&#10;        this.user = user;&#10;        this.password = password;&#10;        try{&#10;            c = getConnection();&#10;        }&#10;        catch(Exception e){&#10;            System.out.println(&quot;Connection failed: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    private Connection getConnection() throws SQLException {&#10;        return DriverManager.getConnection(url, user, password);&#10;    }&#10;&#10;    @Override&#10;    public User findOne(Integer id) {&#10;        if (id == null) throw new IllegalArgumentException(&quot;id is null&quot;);&#10;        String sqlBase = &quot;SELECT id, username, email, password FROM user_base WHERE id = ?&quot;;&#10;        try (PreparedStatement ps = c.prepareStatement(sqlBase)) {&#10;            ps.setInt(1, id);&#10;            try (ResultSet rs = ps.executeQuery()) {&#10;                if (!rs.next()) return null;&#10;                int uid = rs.getInt(&quot;id&quot;);&#10;                String username = rs.getString(&quot;username&quot;);&#10;                String email = rs.getString(&quot;email&quot;);&#10;                String pass = rs.getString(&quot;password&quot;);&#10;                User result = loadPersoana(c, uid, username, email, pass);&#10;                if (result != null) return result;&#10;                result = loadDuck(c, uid, username, email, pass);&#10;                return result != null ? result : null;&#10;            }&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB findOne error: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    private Persoana loadPersoana(Connection c, int id, String username, String email, String pass) throws SQLException {&#10;        String sql = &quot;SELECT nume, prenume, ocupatie, data_nasterii, nivel_empatie FROM persoana WHERE id = ?&quot;;&#10;        try (PreparedStatement ps = c.prepareStatement(sql)) {&#10;            ps.setInt(1, id);&#10;            try (ResultSet rs = ps.executeQuery()) {&#10;                if (!rs.next()) return null;&#10;                String nume = rs.getString(&quot;nume&quot;);&#10;                String prenume = rs.getString(&quot;prenume&quot;);&#10;                String ocupatie = rs.getString(&quot;ocupatie&quot;);&#10;                java.sql.Date dn = rs.getDate(&quot;data_nasterii&quot;);&#10;                LocalDate dataNasterii = dn != null ? dn.toLocalDate() : LocalDate.now();&#10;                int nivelEmpatie = rs.getInt(&quot;nivel_empatie&quot;);&#10;                return new Persoana(id, username, email, pass, nume, prenume, ocupatie, dataNasterii, nivelEmpatie);&#10;            }&#10;        }&#10;    }&#10;&#10;    private Duck loadDuck(Connection c, int id, String username, String email, String pass) throws SQLException {&#10;        String sql = &quot;SELECT tip_rata, viteza, rezistenta FROM duck WHERE id = ?&quot;;&#10;        try (PreparedStatement ps = c.prepareStatement(sql)) {&#10;            ps.setInt(1, id);&#10;            try (ResultSet rs = ps.executeQuery()) {&#10;                if (!rs.next()) return null;&#10;                return buildDuckEntity(id, username, email, pass,&#10;                        rs.getString(&quot;tip_rata&quot;), rs.getDouble(&quot;viteza&quot;), rs.getDouble(&quot;rezistenta&quot;));&#10;            }&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public Iterable&lt;User&gt; findAll() {&#10;        Map&lt;Integer, User&gt; map = new LinkedHashMap&lt;&gt;();&#10;        String sqlPers = &quot;SELECT ub.id, ub.username, ub.email, ub.password, p.nume, p.prenume, p.ocupatie, p.data_nasterii, p.nivel_empatie &quot; +&#10;                &quot;FROM user_base ub JOIN persoana p ON ub.id = p.id&quot;;&#10;        String sqlDuck = &quot;SELECT ub.id, ub.username, ub.email, ub.password, d.tip_rata, d.viteza, d.rezistenta &quot; +&#10;                &quot;FROM user_base ub JOIN duck d ON ub.id = d.id&quot;;&#10;        try (Statement st = c.createStatement()) {&#10;            try (ResultSet rs = st.executeQuery(sqlPers)) {&#10;                while (rs.next()) {&#10;                    int id = rs.getInt(&quot;id&quot;);&#10;                    String username = rs.getString(&quot;username&quot;);&#10;                    String email = rs.getString(&quot;email&quot;);&#10;                    String pass = rs.getString(&quot;password&quot;);&#10;                    String nume = rs.getString(&quot;nume&quot;);&#10;                    String prenume = rs.getString(&quot;prenume&quot;);&#10;                    String ocupatie = rs.getString(&quot;ocupatie&quot;);&#10;                    java.sql.Date dn = rs.getDate(&quot;data_nasterii&quot;);&#10;                    LocalDate dataNasterii = dn != null ? dn.toLocalDate() : LocalDate.now();&#10;                    int nivelEmpatie = rs.getInt(&quot;nivel_empatie&quot;);&#10;                    map.put(id, new Persoana(id, username, email, pass, nume, prenume, ocupatie, dataNasterii, nivelEmpatie));&#10;                }&#10;            }&#10;            try (ResultSet rs = st.executeQuery(sqlDuck)) {&#10;                while (rs.next()) {&#10;                    int id = rs.getInt(&quot;id&quot;);&#10;                    String username = rs.getString(&quot;username&quot;);&#10;                    String email = rs.getString(&quot;email&quot;);&#10;                    String pass = rs.getString(&quot;password&quot;);&#10;                    map.put(id, buildDuckEntity(id, username, email, pass,&#10;                            rs.getString(&quot;tip_rata&quot;), rs.getDouble(&quot;viteza&quot;), rs.getDouble(&quot;rezistenta&quot;)));&#10;                }&#10;            }&#10;            loadFriendships(c, map);&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB findAll error: &quot; + e.getMessage());&#10;        }&#10;        return map.values();&#10;    }&#10;&#10;    private void loadFriendships(Connection c, Map&lt;Integer, User&gt; map) throws SQLException {&#10;        if (map.isEmpty()) return;&#10;        String sql = &quot;SELECT user_id, friend_id FROM user_friend&quot;;&#10;        try (Statement st = c.createStatement(); ResultSet rs = st.executeQuery(sql)) {&#10;            while (rs.next()) {&#10;                int u1 = rs.getInt(&quot;user_id&quot;);&#10;                int u2 = rs.getInt(&quot;friend_id&quot;);&#10;                User user1 = map.get(u1);&#10;                User user2 = map.get(u2);&#10;                if (user1 != null &amp;&amp; user2 != null) {&#10;                    user1.addFriend(user2);&#10;                    user2.addFriend(user1);&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    public void saveFriendship(int id1, int id2) {&#10;        if (id1 == id2) throw new RepoError(&quot;Cannot friend self&quot;);&#10;        int a = Math.min(id1, id2);&#10;        int b = Math.max(id1, id2);&#10;        String sql = &quot;INSERT INTO user_friend(user_id, friend_id) VALUES(?,?) ON CONFLICT DO NOTHING&quot;;&#10;        try (PreparedStatement ps = c.prepareStatement(sql)) {&#10;            ps.setInt(1, a);&#10;            ps.setInt(2, b);&#10;            ps.executeUpdate();&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB saveFriendship error: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    public void deleteFriendship(int id1, int id2) {&#10;        int a = Math.min(id1, id2);&#10;        int b = Math.max(id1, id2);&#10;        String sql = &quot;DELETE FROM user_friend WHERE user_id = ? AND friend_id = ?&quot;;&#10;        try (PreparedStatement ps = c.prepareStatement(sql)) {&#10;            ps.setInt(1, a);&#10;            ps.setInt(2, b);&#10;            ps.executeUpdate();&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB deleteFriendship error: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public User findByEmail(String email) {&#10;        if (email == null) {&#10;            return null;&#10;        }&#10;        String sql = &quot;SELECT id FROM user_base WHERE email = ?&quot;;&#10;        try (PreparedStatement ps = c.prepareStatement(sql)) {&#10;            ps.setString(1, email.toLowerCase());&#10;            try (ResultSet rs = ps.executeQuery()) {&#10;                if (!rs.next()) {&#10;                    return null;&#10;                }&#10;                return findOne(rs.getInt(&quot;id&quot;));&#10;            }&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB findByEmail error: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public boolean emailExists(String email) {&#10;        if (email == null) {&#10;            return false;&#10;        }&#10;        String sql = &quot;SELECT 1 FROM user_base WHERE email = ?&quot;;&#10;        try (PreparedStatement ps = c.prepareStatement(sql)) {&#10;            ps.setString(1, email.toLowerCase());&#10;            try (ResultSet rs = ps.executeQuery()) {&#10;                return rs.next();&#10;            }&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB emailExists error: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public User save(User entity) throws RepoError {&#10;        if (entity == null) throw new IllegalArgumentException(&quot;user is null&quot;);&#10;        if (emailExists(entity.getEmail())) {&#10;            throw new RepoError(&quot;Email already exists&quot;);&#10;        }&#10;        String sqlBase = &quot;INSERT INTO user_base(username, email, password) VALUES(?,?,?)&quot;;&#10;        try{&#10;            c.setAutoCommit(false);&#10;            int generatedId;&#10;            try (PreparedStatement ps = c.prepareStatement(sqlBase,Statement.RETURN_GENERATED_KEYS)) {&#10;                ps.setString(1, entity.getUsername());&#10;                ps.setString(2, entity.getEmail());&#10;                ps.setString(3, entity.getPassword());&#10;                ps.executeUpdate();&#10;                try (ResultSet rs = ps.getGeneratedKeys()) {&#10;                    if (rs.next()) {&#10;                        generatedId = rs.getInt(1);&#10;                        entity.setId(generatedId);&#10;                    } else {&#10;                        c.rollback();&#10;                        throw new RepoError(&quot;DB save error: failed to retrieve generated id&quot;);&#10;                    }&#10;                }&#10;            }&#10;            if (entity instanceof Persoana p) {&#10;                String sqlP = &quot;INSERT INTO persoana(id,nume, prenume, ocupatie, data_nasterii, nivel_empatie) VALUES(?,?,?,?,?,?)&quot;;&#10;                try (PreparedStatement ps = c.prepareStatement(sqlP)) {&#10;                    ps.setInt(1, generatedId);&#10;                    ps.setString(2, p.getNume());&#10;                    ps.setString(3, p.getPrenume());&#10;                    ps.setString(4, p.getOcupatie());&#10;                    ps.setDate(5, java.sql.Date.valueOf(p.getDataNasterii()));&#10;                    ps.setInt(6, p.getNivelEmpatie());&#10;                    ps.executeUpdate();&#10;                }&#10;            } else if (entity instanceof Duck d) {&#10;                String sqlD = &quot;INSERT INTO duck(id,tip_rata, viteza, rezistenta) VALUES(?,?,?,?)&quot;;&#10;                try (PreparedStatement ps = c.prepareStatement(sqlD)) {&#10;                    ps.setInt(1, generatedId);&#10;                    ps.setString(2, d.getTipRata().name());&#10;                    ps.setDouble(3, d.getViteza());&#10;                    ps.setDouble(4, d.getRezistenta());&#10;                    ps.executeUpdate();&#10;                }&#10;            } else {&#10;                throw new RepoError(&quot;Unknown user subtype&quot;);&#10;            }&#10;            c.commit();&#10;            return entity;&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB save error: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public User delete(Integer id) {&#10;        if (id == null) throw new IllegalArgumentException(&quot;id is null&quot;);&#10;        User existing = findOne(id);&#10;        if (existing == null) return null;&#10;        String sqlBase = &quot;DELETE FROM user_base WHERE id = ?&quot;; // cascades to subtype tables &amp; friendships&#10;        try (PreparedStatement ps = c.prepareStatement(sqlBase)) {&#10;            ps.setInt(1, id);&#10;            ps.executeUpdate();&#10;            return existing;&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB delete error: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public Iterable&lt;Duck&gt; findAllDucks() {&#10;        return findDuckPage(0, Integer.MAX_VALUE, null).getItems();&#10;    }&#10;&#10;    @Override&#10;    public PageResult&lt;User&gt; findPage(int pageIndex, int pageSize) {&#10;        return fetchPage(pageIndex, pageSize, null);&#10;    }&#10;&#10;    @Override&#10;    public PageResult&lt;Duck&gt; findDuckPage(int pageIndex, int pageSize, TipRata filter) {&#10;        PageSpec spec = (filter == null)&#10;                ? PageSpec.duck()&#10;                : switch (filter) {&#10;                    case FLYING -&gt; PageSpec.flying();&#10;                    case SWIMMING -&gt; PageSpec.swimming();&#10;                    case FLYING_AND_SWIMMING -&gt; PageSpec.amphibious();&#10;                };&#10;        PageResult&lt;User&gt; page = fetchPage(pageIndex, pageSize, spec);&#10;        return new PageResult&lt;&gt;(page.getItems().stream().map(Duck.class::cast).toList(), pageIndex, pageSize, page.getTotalItems());&#10;    }&#10;&#10;    private PageResult&lt;User&gt; fetchPage(int pageIndex, int pageSize, PageSpec spec) {&#10;        // fetches a page of users according to the given PageSpec (or all if null)&#10;        if (pageIndex &lt; 0 || pageSize &lt;= 0) {&#10;            throw new RepoError(&quot;Invalid pagination arguments&quot;);&#10;        }&#10;        PageSpec effective = spec != null ? spec : PageSpec.all();&#10;        long total = countEntities(effective);&#10;        Map&lt;Integer, User&gt; items = new LinkedHashMap&lt;&gt;();&#10;        try (PreparedStatement ps = c.prepareStatement(effective.sql)) {&#10;            ps.setInt(1, pageIndex * pageSize);&#10;            ps.setInt(2, pageSize);&#10;            try (ResultSet rs = ps.executeQuery()) {&#10;                while (rs.next()) {&#10;                    items.putAll(createUserFromRow(rs));&#10;                }&#10;            }&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB pagination error: &quot; + e.getMessage());&#10;        }&#10;        try {&#10;            loadFriendships(c, items);&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB load friendships error: &quot; + e.getMessage());&#10;        }&#10;        return new PageResult&lt;&gt;(items.values().stream().toList(), pageIndex, pageSize, total);&#10;    }&#10;&#10;    private long countEntities(PageSpec spec) {&#10;        try (PreparedStatement ps = c.prepareStatement(spec.countSql);&#10;             ResultSet rs = ps.executeQuery()) {&#10;            return rs.next() ? rs.getLong(1) : 0;&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB count error: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    private Map&lt;Integer, User&gt; createUserFromRow(ResultSet rs) throws SQLException {&#10;        int id = rs.getInt(&quot;id&quot;);&#10;        String username = rs.getString(&quot;username&quot;);&#10;        String email = rs.getString(&quot;email&quot;);&#10;        String pass = rs.getString(&quot;password&quot;);&#10;        Map&lt;Integer, User&gt; result = new LinkedHashMap&lt;&gt;();&#10;        if (rs.getString(&quot;nume&quot;) != null) {&#10;            String nume = rs.getString(&quot;nume&quot;);&#10;            String prenume = rs.getString(&quot;prenume&quot;);&#10;            String ocupatie = rs.getString(&quot;ocupatie&quot;);&#10;            java.sql.Date dn = rs.getDate(&quot;data_nasterii&quot;);&#10;            LocalDate dataNasterii = dn != null ? dn.toLocalDate() : LocalDate.now();&#10;            int nivelEmpatie = rs.getInt(&quot;nivel_empatie&quot;);&#10;            result.put(id, new Persoana(id, username, email, pass, nume, prenume, ocupatie, dataNasterii, nivelEmpatie));&#10;        } else {&#10;            result.put(id, buildDuckEntity(id, username, email, pass,&#10;                    rs.getString(&quot;tip_rata&quot;), rs.getDouble(&quot;viteza&quot;), rs.getDouble(&quot;rezistenta&quot;)));&#10;        }&#10;        return result;&#10;    }&#10;&#10;    private Duck buildDuckEntity(int id, String username, String email, String pass, String tipRataStr, double viteza, double rezistenta) {&#10;        TipRata tip = TipRata.valueOf(tipRataStr);&#10;        return switch (tip) {&#10;            case FLYING -&gt; new FlyingDuck(id, username, email, pass, viteza, rezistenta);&#10;            case SWIMMING -&gt; new SwimmingDuck(id, username, email, pass, viteza, rezistenta);&#10;            case FLYING_AND_SWIMMING -&gt; new AmphibiousDuck(id, username, email, pass, viteza, rezistenta);&#10;        };&#10;    }&#10;&#10;    @Override&#10;    public void updatePassword(int userId, String hashedPassword) {&#10;        String sql = &quot;UPDATE user_base SET password = ? WHERE id = ?&quot;;&#10;        try (PreparedStatement ps = c.prepareStatement(sql)) {&#10;            ps.setString(1, hashedPassword);&#10;            ps.setInt(2, userId);&#10;            ps.executeUpdate();&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB updatePassword error: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    private record PageSpec(String sql, String countSql) {&#10;        static PageSpec all() {&#10;            // prepares query for all users (Persoana and Duck)&#10;            String base = &quot;WITH ordered AS (&quot; +&#10;                    &quot;SELECT ub.id, ub.username, ub.email, ub.password, p.nume, p.prenume, p.ocupatie, p.data_nasterii, p.nivel_empatie, &quot; +&#10;                    &quot;NULL AS tip_rata, NULL AS viteza, NULL AS rezistenta FROM user_base ub JOIN persoana p ON ub.id = p.id &quot; +&#10;                    &quot;UNION ALL &quot; +&#10;                    &quot;SELECT ub.id, ub.username, ub.email, ub.password, NULL, NULL, NULL, NULL, NULL, d.tip_rata, d.viteza, d.rezistenta FROM user_base ub JOIN duck d ON ub.id = d.id) &quot; +&#10;                    &quot;SELECT * FROM ordered ORDER BY id OFFSET ? LIMIT ?&quot;;&#10;            String count = &quot;SELECT (SELECT COUNT(*) FROM persoana) + (SELECT COUNT(*) FROM duck)&quot;;&#10;            return new PageSpec(base, count);&#10;        }&#10;        static PageSpec duck() {&#10;            return typed(null);&#10;        }&#10;        static PageSpec flying() { return typed(&quot;FLYING&quot;); }&#10;        static PageSpec swimming() { return typed(&quot;SWIMMING&quot;); }&#10;        static PageSpec amphibious() { return typed(&quot;FLYING_AND_SWIMMING&quot;); }&#10;        private static PageSpec typed(String type) {&#10;            // prepares query for ducks of given type (or all if type==null)&#10;            String whereClause = type == null ? &quot;&quot; : &quot; WHERE d.tip_rata = '&quot; + type + &quot;'&quot;;&#10;            String sql = &quot;SELECT ub.id, ub.username, ub.email, ub.password, NULL AS nume, NULL AS prenume, NULL AS ocupatie, NULL AS data_nasterii, NULL AS nivel_empatie, d.tip_rata, d.viteza, d.rezistenta &quot; +&#10;                    &quot;FROM user_base ub JOIN duck d ON ub.id = d.id&quot; + whereClause + &quot; ORDER BY ub.id OFFSET ? LIMIT ?&quot;;&#10;            String count = &quot;SELECT COUNT(*) FROM duck&quot; + (type == null ? &quot;&quot; : &quot; WHERE tip_rata = '&quot; + type + &quot;'&quot;);&#10;            return new PageSpec(sql, count);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package repo;&#10;&#10;import domain.*;&#10;import errors.RepoError;&#10;import util.PageResult;&#10;&#10;import java.sql.*;&#10;import java.time.LocalDate;&#10;import java.util.ArrayList;&#10;import java.util.LinkedHashMap;&#10;import java.util.List;&#10;import java.util.Map;&#10;&#10;/**&#10; * JDBC-based repository for persisting {@link User} entities (Persoana and Duck subclasses)&#10; * in a PostgreSQL database. This implementation uses three tables:&#10; *   user_base(id, username, email, password)&#10; *   persoana(id FK -&gt; user_base.id, nume, prenume, ocupatie, data_nasterii, nivel_empatie)&#10; *   duck(id FK -&gt; user_base.id, tip_rata, viteza, rezistenta)&#10; *   user_friend(user_id, friend_id) symmetrical undirected friendship (stored with user_id &lt; friend_id)&#10; *&#10; * Friend relationships now persisted in user_friend; loaded by findAll. findOne currently loads only the base entity.&#10; */&#10;public class PostgresUserRepository implements UserRepository {&#10;    private final String url;&#10;    private final String user;&#10;    private final String password;&#10;    Connection c;&#10;&#10;    public PostgresUserRepository(String url, String user, String password) {&#10;        this.url = url;&#10;        this.user = user;&#10;        this.password = password;&#10;        try{&#10;            c = getConnection();&#10;        }&#10;        catch(Exception e){&#10;            System.out.println(&quot;Connection failed: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    private Connection getConnection() throws SQLException {&#10;        return DriverManager.getConnection(url, user, password);&#10;    }&#10;&#10;    @Override&#10;    public User findOne(Integer id) {&#10;        if (id == null) throw new IllegalArgumentException(&quot;id is null&quot;);&#10;        String sqlBase = &quot;SELECT id, username, email, password FROM user_base WHERE id = ?&quot;;&#10;        try (PreparedStatement ps = c.prepareStatement(sqlBase)) {&#10;            ps.setInt(1, id);&#10;            try (ResultSet rs = ps.executeQuery()) {&#10;                if (!rs.next()) return null;&#10;                int uid = rs.getInt(&quot;id&quot;);&#10;                String username = rs.getString(&quot;username&quot;);&#10;                String email = rs.getString(&quot;email&quot;);&#10;                String pass = rs.getString(&quot;password&quot;);&#10;                User result = loadPersoana(c, uid, username, email, pass);&#10;                if (result != null) return result;&#10;                result = loadDuck(c, uid, username, email, pass);&#10;                return result != null ? result : null;&#10;            }&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB findOne error: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    private Persoana loadPersoana(Connection c, int id, String username, String email, String pass) throws SQLException {&#10;        String sql = &quot;SELECT nume, prenume, ocupatie, data_nasterii, nivel_empatie FROM persoana WHERE id = ?&quot;;&#10;        try (PreparedStatement ps = c.prepareStatement(sql)) {&#10;            ps.setInt(1, id);&#10;            try (ResultSet rs = ps.executeQuery()) {&#10;                if (!rs.next()) return null;&#10;                String nume = rs.getString(&quot;nume&quot;);&#10;                String prenume = rs.getString(&quot;prenume&quot;);&#10;                String ocupatie = rs.getString(&quot;ocupatie&quot;);&#10;                java.sql.Date dn = rs.getDate(&quot;data_nasterii&quot;);&#10;                LocalDate dataNasterii = dn != null ? dn.toLocalDate() : LocalDate.now();&#10;                int nivelEmpatie = rs.getInt(&quot;nivel_empatie&quot;);&#10;                return new Persoana(id, username, email, pass, nume, prenume, ocupatie, dataNasterii, nivelEmpatie);&#10;            }&#10;        }&#10;    }&#10;&#10;    private Duck loadDuck(Connection c, int id, String username, String email, String pass) throws SQLException {&#10;        String sql = &quot;SELECT tip_rata, viteza, rezistenta FROM duck WHERE id = ?&quot;;&#10;        try (PreparedStatement ps = c.prepareStatement(sql)) {&#10;            ps.setInt(1, id);&#10;            try (ResultSet rs = ps.executeQuery()) {&#10;                if (!rs.next()) return null;&#10;                return buildDuckEntity(id, username, email, pass,&#10;                        rs.getString(&quot;tip_rata&quot;), rs.getDouble(&quot;viteza&quot;), rs.getDouble(&quot;rezistenta&quot;));&#10;            }&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public Iterable&lt;User&gt; findAll() {&#10;        Map&lt;Integer, User&gt; map = new LinkedHashMap&lt;&gt;();&#10;        String sqlPers = &quot;SELECT ub.id, ub.username, ub.email, ub.password, p.nume, p.prenume, p.ocupatie, p.data_nasterii, p.nivel_empatie &quot; +&#10;                &quot;FROM user_base ub JOIN persoana p ON ub.id = p.id&quot;;&#10;        String sqlDuck = &quot;SELECT ub.id, ub.username, ub.email, ub.password, d.tip_rata, d.viteza, d.rezistenta &quot; +&#10;                &quot;FROM user_base ub JOIN duck d ON ub.id = d.id&quot;;&#10;        try (Statement st = c.createStatement()) {&#10;            try (ResultSet rs = st.executeQuery(sqlPers)) {&#10;                while (rs.next()) {&#10;                    int id = rs.getInt(&quot;id&quot;);&#10;                    String username = rs.getString(&quot;username&quot;);&#10;                    String email = rs.getString(&quot;email&quot;);&#10;                    String pass = rs.getString(&quot;password&quot;);&#10;                    String nume = rs.getString(&quot;nume&quot;);&#10;                    String prenume = rs.getString(&quot;prenume&quot;);&#10;                    String ocupatie = rs.getString(&quot;ocupatie&quot;);&#10;                    java.sql.Date dn = rs.getDate(&quot;data_nasterii&quot;);&#10;                    LocalDate dataNasterii = dn != null ? dn.toLocalDate() : LocalDate.now();&#10;                    int nivelEmpatie = rs.getInt(&quot;nivel_empatie&quot;);&#10;                    map.put(id, new Persoana(id, username, email, pass, nume, prenume, ocupatie, dataNasterii, nivelEmpatie));&#10;                }&#10;            }&#10;            try (ResultSet rs = st.executeQuery(sqlDuck)) {&#10;                while (rs.next()) {&#10;                    int id = rs.getInt(&quot;id&quot;);&#10;                    String username = rs.getString(&quot;username&quot;);&#10;                    String email = rs.getString(&quot;email&quot;);&#10;                    String pass = rs.getString(&quot;password&quot;);&#10;                    map.put(id, buildDuckEntity(id, username, email, pass,&#10;                            rs.getString(&quot;tip_rata&quot;), rs.getDouble(&quot;viteza&quot;), rs.getDouble(&quot;rezistenta&quot;)));&#10;                }&#10;            }&#10;            loadFriendships(c, map);&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB findAll error: &quot; + e.getMessage());&#10;        }&#10;        return map.values();&#10;    }&#10;&#10;    private void loadFriendships(Connection c, Map&lt;Integer, User&gt; map) throws SQLException {&#10;        if (map.isEmpty()) return;&#10;        String sql = &quot;SELECT user_id, friend_id FROM user_friend&quot;;&#10;        try (Statement st = c.createStatement(); ResultSet rs = st.executeQuery(sql)) {&#10;            while (rs.next()) {&#10;                int u1 = rs.getInt(&quot;user_id&quot;);&#10;                int u2 = rs.getInt(&quot;friend_id&quot;);&#10;                User user1 = map.get(u1);&#10;                User user2 = map.get(u2);&#10;                if (user1 != null &amp;&amp; user2 != null) {&#10;                    user1.addFriend(user2);&#10;                    user2.addFriend(user1);&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    public void saveFriendship(int id1, int id2) {&#10;        if (id1 == id2) throw new RepoError(&quot;Cannot friend self&quot;);&#10;        int a = Math.min(id1, id2);&#10;        int b = Math.max(id1, id2);&#10;        String sql = &quot;INSERT INTO user_friend(user_id, friend_id) VALUES(?,?) ON CONFLICT DO NOTHING&quot;;&#10;        try (PreparedStatement ps = c.prepareStatement(sql)) {&#10;            ps.setInt(1, a);&#10;            ps.setInt(2, b);&#10;            ps.executeUpdate();&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB saveFriendship error: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    public void deleteFriendship(int id1, int id2) {&#10;        int a = Math.min(id1, id2);&#10;        int b = Math.max(id1, id2);&#10;        String sql = &quot;DELETE FROM user_friend WHERE user_id = ? AND friend_id = ?&quot;;&#10;        try (PreparedStatement ps = c.prepareStatement(sql)) {&#10;            ps.setInt(1, a);&#10;            ps.setInt(2, b);&#10;            ps.executeUpdate();&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB deleteFriendship error: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public User findByEmail(String email) {&#10;        if (email == null) {&#10;            return null;&#10;        }&#10;        String sql = &quot;SELECT id FROM user_base WHERE email = ?&quot;;&#10;        try (PreparedStatement ps = c.prepareStatement(sql)) {&#10;            ps.setString(1, email.toLowerCase());&#10;            try (ResultSet rs = ps.executeQuery()) {&#10;                if (!rs.next()) {&#10;                    return null;&#10;                }&#10;                return findOne(rs.getInt(&quot;id&quot;));&#10;            }&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB findByEmail error: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public boolean emailExists(String email) {&#10;        if (email == null) {&#10;            return false;&#10;        }&#10;        String sql = &quot;SELECT 1 FROM user_base WHERE email = ?&quot;;&#10;        try (PreparedStatement ps = c.prepareStatement(sql)) {&#10;            ps.setString(1, email.toLowerCase());&#10;            try (ResultSet rs = ps.executeQuery()) {&#10;                return rs.next();&#10;            }&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB emailExists error: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public User save(User entity) throws RepoError {&#10;        if (entity == null) throw new IllegalArgumentException(&quot;user is null&quot;);&#10;        if (emailExists(entity.getEmail())) {&#10;            throw new RepoError(&quot;Email already exists&quot;);&#10;        }&#10;        String sqlBase = &quot;INSERT INTO user_base(username, email, password) VALUES(?,?,?)&quot;;&#10;        try{&#10;            c.setAutoCommit(false);&#10;            int generatedId;&#10;            try (PreparedStatement ps = c.prepareStatement(sqlBase,Statement.RETURN_GENERATED_KEYS)) {&#10;                ps.setString(1, entity.getUsername());&#10;                ps.setString(2, entity.getEmail());&#10;                ps.setString(3, entity.getPassword());&#10;                ps.executeUpdate();&#10;                try (ResultSet rs = ps.getGeneratedKeys()) {&#10;                    if (rs.next()) {&#10;                        generatedId = rs.getInt(1);&#10;                        entity.setId(generatedId);&#10;                    } else {&#10;                        c.rollback();&#10;                        throw new RepoError(&quot;DB save error: failed to retrieve generated id&quot;);&#10;                    }&#10;                }&#10;            }&#10;            if (entity instanceof Persoana p) {&#10;                String sqlP = &quot;INSERT INTO persoana(id,nume, prenume, ocupatie, data_nasterii, nivel_empatie) VALUES(?,?,?,?,?,?)&quot;;&#10;                try (PreparedStatement ps = c.prepareStatement(sqlP)) {&#10;                    ps.setInt(1, generatedId);&#10;                    ps.setString(2, p.getNume());&#10;                    ps.setString(3, p.getPrenume());&#10;                    ps.setString(4, p.getOcupatie());&#10;                    ps.setDate(5, java.sql.Date.valueOf(p.getDataNasterii()));&#10;                    ps.setInt(6, p.getNivelEmpatie());&#10;                    ps.executeUpdate();&#10;                }&#10;            } else if (entity instanceof Duck d) {&#10;                String sqlD = &quot;INSERT INTO duck(id,tip_rata, viteza, rezistenta) VALUES(?,?,?,?)&quot;;&#10;                try (PreparedStatement ps = c.prepareStatement(sqlD)) {&#10;                    ps.setInt(1, generatedId);&#10;                    ps.setString(2, d.getTipRata().name());&#10;                    ps.setDouble(3, d.getViteza());&#10;                    ps.setDouble(4, d.getRezistenta());&#10;                    ps.executeUpdate();&#10;                }&#10;            } else {&#10;                throw new RepoError(&quot;Unknown user subtype&quot;);&#10;            }&#10;            c.commit();&#10;            return entity;&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB save error: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public User delete(Integer id) {&#10;        if (id == null) throw new IllegalArgumentException(&quot;id is null&quot;);&#10;        User existing = findOne(id);&#10;        if (existing == null) return null;&#10;        String sqlBase = &quot;DELETE FROM user_base WHERE id = ?&quot;; // cascades to subtype tables &amp; friendships&#10;        try (PreparedStatement ps = c.prepareStatement(sqlBase)) {&#10;            ps.setInt(1, id);&#10;            ps.executeUpdate();&#10;            return existing;&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB delete error: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public Iterable&lt;Duck&gt; findAllDucks() {&#10;        return findDuckPage(0, Integer.MAX_VALUE, null).getItems();&#10;    }&#10;&#10;    @Override&#10;    public PageResult&lt;User&gt; findPage(int pageIndex, int pageSize) {&#10;        return fetchPage(pageIndex, pageSize, null);&#10;    }&#10;&#10;    @Override&#10;    public PageResult&lt;Duck&gt; findDuckPage(int pageIndex, int pageSize, TipRata filter) {&#10;        PageSpec spec = (filter == null)&#10;                ? PageSpec.duck()&#10;                : switch (filter) {&#10;                    case FLYING -&gt; PageSpec.flying();&#10;                    case SWIMMING -&gt; PageSpec.swimming();&#10;                    case FLYING_AND_SWIMMING -&gt; PageSpec.amphibious();&#10;                };&#10;        PageResult&lt;User&gt; page = fetchPage(pageIndex, pageSize, spec);&#10;        return new PageResult&lt;&gt;(page.getItems().stream().map(Duck.class::cast).toList(), pageIndex, pageSize, page.getTotalItems());&#10;    }&#10;&#10;    private PageResult&lt;User&gt; fetchPage(int pageIndex, int pageSize, PageSpec spec) {&#10;        // fetches a page of users according to the given PageSpec (or all if null)&#10;        if (pageIndex &lt; 0 || pageSize &lt;= 0) {&#10;            throw new RepoError(&quot;Invalid pagination arguments&quot;);&#10;        }&#10;        PageSpec effective = spec != null ? spec : PageSpec.all();&#10;        long total = countEntities(effective);&#10;        Map&lt;Integer, User&gt; items = new LinkedHashMap&lt;&gt;();&#10;        try (PreparedStatement ps = c.prepareStatement(effective.sql)) {&#10;            ps.setInt(1, pageIndex * pageSize);&#10;            ps.setInt(2, pageSize);&#10;            try (ResultSet rs = ps.executeQuery()) {&#10;                while (rs.next()) {&#10;                    items.putAll(createUserFromRow(rs));&#10;                }&#10;            }&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB pagination error: &quot; + e.getMessage());&#10;        }&#10;        try {&#10;            loadFriendships(c, items);&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB load friendships error: &quot; + e.getMessage());&#10;        }&#10;        return new PageResult&lt;&gt;(items.values().stream().toList(), pageIndex, pageSize, total);&#10;    }&#10;&#10;    private long countEntities(PageSpec spec) {&#10;        try (PreparedStatement ps = c.prepareStatement(spec.countSql);&#10;             ResultSet rs = ps.executeQuery()) {&#10;            return rs.next() ? rs.getLong(1) : 0;&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB count error: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    private Map&lt;Integer, User&gt; createUserFromRow(ResultSet rs) throws SQLException {&#10;        int id = rs.getInt(&quot;id&quot;);&#10;        String username = rs.getString(&quot;username&quot;);&#10;        String email = rs.getString(&quot;email&quot;);&#10;        String pass = rs.getString(&quot;password&quot;);&#10;        Map&lt;Integer, User&gt; result = new LinkedHashMap&lt;&gt;();&#10;        if (rs.getString(&quot;nume&quot;) != null) {&#10;            String nume = rs.getString(&quot;nume&quot;);&#10;            String prenume = rs.getString(&quot;prenume&quot;);&#10;            String ocupatie = rs.getString(&quot;ocupatie&quot;);&#10;            java.sql.Date dn = rs.getDate(&quot;data_nasterii&quot;);&#10;            LocalDate dataNasterii = dn != null ? dn.toLocalDate() : LocalDate.now();&#10;            int nivelEmpatie = rs.getInt(&quot;nivel_empatie&quot;);&#10;            result.put(id, new Persoana(id, username, email, pass, nume, prenume, ocupatie, dataNasterii, nivelEmpatie));&#10;        } else {&#10;            result.put(id, buildDuckEntity(id, username, email, pass,&#10;                    rs.getString(&quot;tip_rata&quot;), rs.getDouble(&quot;viteza&quot;), rs.getDouble(&quot;rezistenta&quot;)));&#10;        }&#10;        return result;&#10;    }&#10;&#10;    private Duck buildDuckEntity(int id, String username, String email, String pass, String tipRataStr, double viteza, double rezistenta) {&#10;        TipRata tip = TipRata.valueOf(tipRataStr);&#10;        return switch (tip) {&#10;            case FLYING -&gt; new FlyingDuck(id, username, email, pass, viteza, rezistenta);&#10;            case SWIMMING -&gt; new SwimmingDuck(id, username, email, pass, viteza, rezistenta);&#10;            case FLYING_AND_SWIMMING -&gt; new AmphibiousDuck(id, username, email, pass, viteza, rezistenta);&#10;        };&#10;    }&#10;&#10;    @Override&#10;    public void updatePassword(int userId, String hashedPassword) {&#10;        String sql = &quot;UPDATE user_base SET password = ? WHERE id = ?&quot;;&#10;        try (PreparedStatement ps = c.prepareStatement(sql)) {&#10;            ps.setString(1, hashedPassword);&#10;            ps.setInt(2, userId);&#10;            ps.executeUpdate();&#10;        } catch (SQLException e) {&#10;            throw new RepoError(&quot;DB updatePassword error: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    private record PageSpec(String sql, String countSql) {&#10;        static PageSpec all() {&#10;            // prepares query for all users (Persoana and Duck)&#10;            String base = &quot;WITH ordered AS (&quot; +&#10;                    &quot;SELECT ub.id, ub.username, ub.email, ub.password, p.nume, p.prenume, p.ocupatie, p.data_nasterii, p.nivel_empatie, &quot; +&#10;                    &quot;NULL AS tip_rata, NULL AS viteza, NULL AS rezistenta FROM user_base ub JOIN persoana p ON ub.id = p.id &quot; +&#10;                    &quot;UNION ALL &quot; +&#10;                    &quot;SELECT ub.id, ub.username, ub.email, ub.password, NULL, NULL, NULL, NULL, NULL, d.tip_rata, d.viteza, d.rezistenta FROM user_base ub JOIN duck d ON ub.id = d.id) &quot; +&#10;                    &quot;SELECT * FROM ordered ORDER BY id OFFSET ? LIMIT ?&quot;;&#10;            String count = &quot;SELECT (SELECT COUNT(*) FROM persoana) + (SELECT COUNT(*) FROM duck)&quot;;&#10;            return new PageSpec(base, count);&#10;        }&#10;        static PageSpec duck() {&#10;            return typed(null);&#10;        }&#10;        static PageSpec flying() { return typed(&quot;FLYING&quot;); }&#10;        static PageSpec swimming() { return typed(&quot;SWIMMING&quot;); }&#10;        static PageSpec amphibious() { return typed(&quot;FLYING_AND_SWIMMING&quot;); }&#10;        private static PageSpec typed(String type) {&#10;            // prepares query for ducks of given type (or all if type==null)&#10;            String whereClause = type == null ? &quot;&quot; : &quot; WHERE d.tip_rata = '&quot; + type + &quot;'&quot;;&#10;            String sql = &quot;SELECT ub.id, ub.username, ub.email, ub.password, NULL AS nume, NULL AS prenume, NULL AS ocupatie, NULL AS data_nasterii, NULL AS nivel_empatie, d.tip_rata, d.viteza, d.rezistenta &quot; +&#10;                    &quot;FROM user_base ub JOIN duck d ON ub.id = d.id&quot; + whereClause + &quot; ORDER BY ub.id OFFSET ? LIMIT ?&quot;;&#10;            String count = &quot;SELECT COUNT(*) FROM duck&quot; + (type == null ? &quot;&quot; : &quot; WHERE tip_rata = '&quot; + type + &quot;'&quot;);&#10;            return new PageSpec(sql, count);&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/repo/UserRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/repo/UserRepository.java" />
              <option name="originalContent" value="package repo;&#10;&#10; import domain.Duck;&#10;import domain.TipRata;&#10;import domain.User;&#10;import util.PageResult;&#10;/**&#10; * Repository interface for User entities.&#10; */&#10;public interface UserRepository extends Repository&lt;Integer, User&gt;{&#10;    // Additional user-specific methods can be added here&#10;    // Good for SRP :) dont want to need to remake repo when i wanna add&#10;    //new functionality to user repo and i only have the generic&#10;    //repo interface&#10;    Iterable&lt;Duck&gt; findAllDucks();&#10;    PageResult&lt;User&gt; findPage(int pageIndex, int pageSize);&#10;    PageResult&lt;Duck&gt; findDuckPage(int pageIndex, int pageSize, TipRata filter);&#10;    User findByEmail(String email);&#10;    boolean emailExists(String email);&#10;    void updatePassword(int userId, String hashedPassword);&#10;}&#10;" />
              <option name="updatedContent" value="package repo;&#10;&#10; import domain.Duck;&#10;import domain.TipRata;&#10;import domain.User;&#10;import util.PageResult;&#10;/**&#10; * Repository interface for User entities.&#10; */&#10;public interface UserRepository extends Repository&lt;Integer, User&gt;{&#10;    // Additional user-specific methods can be added here&#10;    // Good for SRP :) dont want to need to remake repo when i wanna add&#10;    //new functionality to user repo and i only have the generic&#10;    //repo interface&#10;    Iterable&lt;Duck&gt; findAllDucks();&#10;    PageResult&lt;User&gt; findPage(int pageIndex, int pageSize);&#10;    PageResult&lt;Duck&gt; findDuckPage(int pageIndex, int pageSize, TipRata filter);&#10;    User findByEmail(String email);&#10;    boolean emailExists(String email);&#10;    void updatePassword(int userId, String hashedPassword);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/service/NetworkService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/service/NetworkService.java" />
              <option name="originalContent" value="package service;&#10;&#10;import domain.*;&#10;import errors.RepoError;&#10;import errors.ValidationError;&#10;import repo.EventRepository;&#10;import repo.UserRepository;&#10;import repo.PostgresUserRepository; // added&#10;import repo.PostgresEventRepository;&#10;import repo.CardRepository;&#10;import repo.MessageRepository;&#10;import util.PageResult;&#10;import util.Algorithms;&#10;import util.PasswordHasher;&#10;import validator.ValidationStrategy;&#10;&#10;import java.util.*;&#10;&#10;/**&#10; * Service layer that orchestrates repository access, validation and business&#10; * operations for the social network domain.&#10; */&#10;public class NetworkService {&#10;    private UserRepository userRepository;&#10;    private EventRepository eventRepository;&#10;    private ValidationStrategy&lt;Persoana&gt; persoanaValidator;&#10;    private ValidationStrategy&lt;Duck&gt; duckValidator;&#10;    private final Map&lt;Integer, Card&gt; cards = new HashMap&lt;&gt;();&#10;    private final CardRepository cardRepository;&#10;    private final MessageRepository messageRepository;&#10;&#10;    /**&#10;     * Construct the NetworkService with required dependencies.&#10;     *&#10;     * @param userRepository repository for users&#10;     * @param eventRepository repository for events&#10;     * @param persoanaValidator validator for Persoana instances&#10;     * @param duckValidator validator for Duck instances&#10;     * @param cardRepository repository for cards&#10;     * @param messageRepository repository for messages&#10;     */&#10;    public NetworkService(UserRepository userRepository, EventRepository eventRepository, ValidationStrategy&lt;Persoana&gt; persoanaValidator, ValidationStrategy&lt;Duck&gt; duckValidator, CardRepository cardRepository, MessageRepository messageRepository) {&#10;        this.userRepository = userRepository;&#10;        this.eventRepository = eventRepository;&#10;        this.persoanaValidator = persoanaValidator;&#10;        this.duckValidator = duckValidator;&#10;        this.cardRepository = cardRepository;&#10;        this.messageRepository = messageRepository;&#10;        if(cardRepository != null){&#10;            for (Card card : cardRepository.findAll()) {&#10;                cards.put(card.getId(), card);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Add a new user to the network after validating it.&#10;     *&#10;     * @param user the user to add (Persoana or Duck)&#10;     * @return the saved user&#10;     * @throws ValidationError when validation fails&#10;     * @throws RepoError when repository rejects the save (e.g. duplicate id)&#10;     */&#10;    public User addUser(User user) throws ValidationError, RepoError {&#10;        if(user instanceof Persoana){&#10;            persoanaValidator.validate((Persoana) user);&#10;        }&#10;        else if(user instanceof Duck){&#10;            duckValidator.validate((Duck) user);&#10;        }&#10;        else{&#10;            throw new ValidationError(&quot;Unknown user type&quot;);&#10;        }&#10;        User toPersist = hashPassword(user);&#10;        return userRepository.save(toPersist);&#10;    }&#10;&#10;    private User hashPassword(User user) {&#10;        user.setPassword(PasswordHasher.hash(user.getPassword()));&#10;        return user;&#10;    }&#10;&#10;    public User login(String email, String password) {&#10;        User found = userRepository.findByEmail(email == null ? null : email.toLowerCase());&#10;        if (found == null) {&#10;            throw new RepoError(&quot;Invalid credentials&quot;);&#10;        }&#10;        String stored = found.getPassword();&#10;        boolean isHashed = stored != null &amp;&amp; stored.startsWith(&quot;$2&quot;);&#10;        boolean authenticated;&#10;        if (isHashed) {&#10;            authenticated = PasswordHasher.matches(password, stored);&#10;        } else {&#10;            authenticated = Objects.equals(password, stored);&#10;            if (authenticated) {&#10;                String newHash = PasswordHasher.hash(password);&#10;                userRepository.updatePassword(found.getId(), newHash);&#10;                found.setPassword(newHash);&#10;            }&#10;        }&#10;        if (!authenticated) {&#10;            throw new RepoError(&quot;Invalid credentials&quot;);&#10;        }&#10;        return reloadUser(found.getId());&#10;    }&#10;&#10;    /**&#10;     * Remove a user by id and clean up references from other users' friend lists.&#10;     * Also removes a duck from all cards where it appears.&#10;     *&#10;     * @param id the id of the user to remove&#10;     * @return the removed user&#10;     * @throws RepoError when the user does not exist&#10;     */&#10;    public User removeUser(Integer id){&#10;        User userToRemove=userRepository.delete(id);&#10;        if(userToRemove==null){&#10;            throw new RepoError(&quot;User with id &quot;+id+&quot; not found&quot;);&#10;        }&#10;        for (User u: userRepository.findAll()) {&#10;            u.removeFriend(userToRemove);&#10;        }&#10;        // also remove from cards if it's a Duck&#10;        if (userToRemove instanceof Duck) {&#10;            Duck d = (Duck) userToRemove;&#10;            for (Card c : cards.values()) {&#10;                c.removeDuck(d);&#10;            }&#10;            if (cardRepository != null) {&#10;                cardRepository.removeDuckFromAll(d.getId());&#10;            }&#10;        }&#10;        return userToRemove;&#10;    }&#10;&#10;    /**&#10;     * Create a mutual friendship between two users identified by their ids.&#10;     *&#10;     * @param id1 first user's id&#10;     * @param id2 second user's id&#10;     * @throws RepoError when either user is not found&#10;     */&#10;    public void addFriendship(Integer id1, Integer id2){&#10;        User user1=userRepository.findOne(id1);&#10;        User user2=userRepository.findOne(id2);&#10;        if(user1==null){&#10;            throw new RepoError(&quot;User with id &quot;+id1+&quot; not found&quot;);&#10;        }&#10;        if(user2==null){&#10;            throw new RepoError(&quot;User with id &quot;+id2+&quot; not found&quot;);&#10;        }&#10;        user1.addFriend(user2);&#10;        user2.addFriend(user1);&#10;        if(userRepository instanceof PostgresUserRepository pr){&#10;            pr.saveFriendship(id1, id2);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Remove a mutual friendship between two users (if present).&#10;     *&#10;     * @param id1 first user's id&#10;     * @param id2 second user's id&#10;     */&#10;    public void removeFriendship(Integer id1, Integer id2){&#10;        User user1=userRepository.findOne(id1);&#10;        User user2=userRepository.findOne(id2);&#10;        if(user1!=null){&#10;            user1.removeFriend(user2);&#10;        }&#10;        if(user2!=null){&#10;            user2.removeFriend(user1);&#10;        }&#10;        if(userRepository instanceof PostgresUserRepository pr){&#10;            pr.deleteFriendship(id1, id2);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Retrieve all users from the repository, optionally filtering by user type.&#10;     *&#10;     * @param userType optional class type to filter users (e.g., Persoana.class or Duck.class)&#10;     * @return list of users matching the filter&#10;     */&#10;    public List&lt;User&gt; getAllUsers(Class&lt;? extends User&gt; userType){&#10;        List&lt;User&gt; result = new ArrayList&lt;&gt;();&#10;        for (User u : userRepository.findAll()) {&#10;            if (userType == null || userType.isInstance(u)) {&#10;                result.add(u);&#10;            }&#10;        }&#10;        return result;&#10;    }&#10;&#10;    public PageResult&lt;Duck&gt; getDucksPage(int pageIndex, int pageSize, TipRata filter) {&#10;        return userRepository.findDuckPage(pageIndex, pageSize, filter);&#10;    }&#10;&#10;    public Iterable&lt;Duck&gt; getAllDucks() {&#10;        return userRepository.findAllDucks();&#10;    }&#10;&#10;    /**&#10;     * Compute the number of connected components (communities) in the network.&#10;     *&#10;     * @return number of communities&#10;     */&#10;    public int getNumberOfCommunities(){&#10;        Set&lt;User&gt; visited=new HashSet&lt;&gt;();&#10;        int communities=0;&#10;        for (User user: userRepository.findAll()) {&#10;            if(!visited.contains(user)){&#10;                communities++;&#10;                Algorithms.dfs(user, visited);&#10;            }&#10;        }&#10;        return communities;&#10;    }&#10;&#10;    /**&#10;     * Find the community with the largest diameter (most social community).&#10;     * The method returns the list of users in the community with the maximum&#10;     * shortest-path diameter.&#10;     *&#10;     * @return list of users forming the most social community&#10;     */&#10;    public List&lt;User&gt; getMostSocialCommunity() {&#10;        Set&lt;User&gt; visitedGlobal = new HashSet&lt;&gt;();&#10;        List&lt;User&gt; bestCommunity = new ArrayList&lt;&gt;();&#10;        int maxDiameter = -1;&#10;        for (User user : userRepository.findAll()) {&#10;            if (!visitedGlobal.contains(user)) {&#10;                Set&lt;User&gt; currentCommunitySet = new HashSet&lt;&gt;();&#10;                Algorithms.dfs(user, currentCommunitySet); // Gsete toi membrii&#10;                visitedGlobal.addAll(currentCommunitySet);&#10;                List&lt;User&gt; currentCommunityList = new ArrayList&lt;&gt;(currentCommunitySet);&#10;                int currentDiameter = Algorithms.getDiameter(currentCommunityList);&#10;                if (currentDiameter &gt; maxDiameter) {&#10;                    maxDiameter = currentDiameter;&#10;                    bestCommunity = currentCommunityList;&#10;                }&#10;            }&#10;        }&#10;        System.out.println(&quot;Diametrul maxim gsit: &quot; + maxDiameter);&#10;        return bestCommunity;&#10;    }&#10;&#10;    // CARD operations&#10;    /**&#10;     * Create a card (flock) that can contain ducks and compute their average performance.&#10;     *&#10;     * @param numeCard card name&#10;     * @return created {@link Card}&#10;     */&#10;    public Card createCard(String numeCard){&#10;        Card persisted;&#10;        if (cardRepository != null) {&#10;            // persist first to obtain DB-generated id&#10;            persisted = cardRepository.save(new Card(-1, numeCard));&#10;        } else {&#10;            // fallback to in-memory id assignment&#10;            int newId = cards.keySet().stream().mapToInt(Integer::intValue).max().orElse(0) + 1;&#10;            persisted = new Card(newId, numeCard);&#10;        }&#10;        cards.put(persisted.getId(), persisted);&#10;        return persisted;&#10;    }&#10;&#10;    /**&#10;     * @return view of all created cards&#10;     */&#10;    public Collection&lt;Card&gt; getAllCards(){&#10;        return cards.values();&#10;    }&#10;&#10;    /**&#10;     * Add a duck to a card by their ids.&#10;     *&#10;     * @param cardId card id&#10;     * @param duckId duck user id&#10;     */&#10;    public void addDuckToCard(int cardId, int duckId){&#10;        Card c = cards.get(cardId);&#10;        if(c==null) throw new RepoError(&quot;Card not found&quot;);&#10;        User u = userRepository.findOne(duckId);&#10;        if(!(u instanceof Duck)) throw new RepoError(&quot;User is not a duck or not found&quot;);&#10;        c.addDuck((Duck) u);&#10;        if(cardRepository != null) {&#10;            cardRepository.addDuck(cardId, duckId);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Remove a duck from a card by their ids.&#10;     *&#10;     * @param cardId card id&#10;     * @param duckId duck user id&#10;     */&#10;    public void removeDuckFromCard(int cardId, int duckId){&#10;        Card c = cards.get(cardId);&#10;        if(c==null) throw new RepoError(&quot;Card not found&quot;);&#10;        User u = userRepository.findOne(duckId);&#10;        if(!(u instanceof Duck)) throw new RepoError(&quot;User is not a duck or not found&quot;);&#10;        c.removeDuck((Duck) u);&#10;        if(cardRepository != null) {&#10;            cardRepository.removeDuck(cardId, duckId);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Compute the average performance value for a card.&#10;     *&#10;     * @param cardId card id&#10;     * @return average performance&#10;     */&#10;    public double getCardPerformantaMedie(int cardId){&#10;        Card c = cards.get(cardId);&#10;        if(c==null) throw new RepoError(&quot;Card not found&quot;);&#10;        return c.getPerformantaMedie();&#10;    }&#10;&#10;    // EVENT operations using repository&#10;    /**&#10;     * Create and store a race event with a specific lane count.&#10;     *&#10;     * @param name  event name&#10;     * @param lanes number of lanes (M)&#10;     * @return created {@link RaceEvent} with a DB-generated id&#10;     */&#10;    public RaceEvent createRaceEvent(String name, int lanes){&#10;        // temporary id; PostgresEventRepository should ignore/use its own sequence&#10;        RaceEvent re = new RaceEvent(-1, name, lanes);&#10;        eventRepository.save(re);&#10;        return re;&#10;    }&#10;&#10;    /**&#10;     * @return all events stored in the repository&#10;     */&#10;    public Iterable&lt;Event&gt; getAllEvents(){ return eventRepository.findAll(); }&#10;&#10;    /**&#10;     * Subscribe a user to an event by ids.&#10;     *&#10;     * @param eventId event id&#10;     * @param userId  user id&#10;     */&#10;    public void subscribeToEvent(int eventId, int userId){&#10;        Event e = eventRepository.findOne(eventId);&#10;        if(e==null) throw new RepoError(&quot;Event not found&quot;);&#10;        User u = userRepository.findOne(userId);&#10;        if(u==null) throw new RepoError(&quot;User not found&quot;);&#10;        e.subscribe(u);&#10;        if(eventRepository instanceof PostgresEventRepository pe){&#10;            pe.addSubscriber(eventId, userId);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Unsubscribe a user from an event (no-op if user or event does not exist).&#10;     *&#10;     * @param eventId event id&#10;     * @param userId  user id&#10;     */&#10;    public void unsubscribeFromEvent(int eventId, int userId){&#10;        Event e = eventRepository.findOne(eventId);&#10;        if(e==null) throw new RepoError(&quot;Event not found&quot;);&#10;        User u = userRepository.findOne(userId);&#10;        if(u!=null) {&#10;            e.unsubscribe(u);&#10;            if(eventRepository instanceof PostgresEventRepository pe){&#10;                pe.removeSubscriber(eventId, userId);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Run a race event identified by id. It gathers all users that are both Duck and Inotator,&#10;     * selects up to M participants, runs the optimizer and returns a textual report.&#10;     *&#10;     * @param eventId the race event id&#10;     * @return list of report lines (one per lane + minimal total time)&#10;     */&#10;    public List&lt;String&gt; runRace(int eventId){&#10;        Event ev = eventRepository.findOne(eventId);&#10;        if(!(ev instanceof RaceEvent)) throw new RepoError(&quot;Event is not a race&quot;);&#10;        RaceEvent re = (RaceEvent) ev;&#10;        List&lt;Duck&gt; allDucks = new ArrayList&lt;&gt;();&#10;        for (Duck duck : userRepository.findAllDucks()) {&#10;            if (duck instanceof Inotator) {&#10;                allDucks.add(duck);&#10;            }&#10;        }&#10;        re.selectParticipants(allDucks);&#10;        List&lt;String&gt; report = re.runRaceAndReport();&#10;        if(eventRepository instanceof PostgresEventRepository pe){&#10;            pe.addNotification(eventId, &quot;Race finished. Results available.&quot;);&#10;        }&#10;        return report;&#10;    }&#10;&#10;    /**&#10;     * Configure lane distances for a race event.&#10;     *&#10;     * @param eventId   race event id&#10;     * @param distances per-lane distances (exactly M values)&#10;     */&#10;    public void setRaceDistances(int eventId, double[] distances){&#10;        Event ev = eventRepository.findOne(eventId);&#10;        if(!(ev instanceof RaceEvent)) throw new errors.RepoError(&quot;Event is not a race&quot;);&#10;        ((RaceEvent) ev).setDistances(distances);&#10;    }&#10;&#10;    /**&#10;     * Get the notifications received by a specific user.&#10;     *&#10;     * @param userId id of the user&#10;     * @return unmodifiable list of messages&#10;     * @throws RepoError if the user is not found&#10;     */&#10;    public List&lt;String&gt; getUserNotifications(int userId){&#10;        User u = userRepository.findOne(userId);&#10;        if(u==null) throw new RepoError(&quot;User not found&quot;);&#10;        return u.getNotifications();&#10;    }&#10;&#10;    public void addFriendshipByEmail(String emailA, String emailB) {&#10;        User a = requireUserByEmail(emailA);&#10;        User b = requireUserByEmail(emailB);&#10;        addFriendship(a.getId(), b.getId());&#10;    }&#10;&#10;    public void removeFriendshipByEmail(String emailA, String emailB) {&#10;        User a = requireUserByEmail(emailA);&#10;        User b = requireUserByEmail(emailB);&#10;        removeFriendship(a.getId(), b.getId());&#10;    }&#10;&#10;    public User requireUserByEmail(String email) {&#10;        User user = userRepository.findByEmail(email == null ? null : email.toLowerCase());&#10;        if (user == null) {&#10;            throw new RepoError(&quot;User not found for email &quot; + email);&#10;        }&#10;        return user;&#10;    }&#10;&#10;    public User getUserByEmail(String email) {&#10;        if (email == null) {&#10;            return null;&#10;        }&#10;        return userRepository.findByEmail(email.toLowerCase());&#10;    }&#10;&#10;    public User reloadUser(int userId) {&#10;        for (User user : userRepository.findAll()) {&#10;            if (user.getId() == userId) {&#10;                return user;&#10;            }&#10;        }&#10;        return null;&#10;    }&#10;&#10;    public List&lt;User&gt; getFriendsFor(int userId) {&#10;        User user = reloadUser(userId);&#10;        if (user == null) {&#10;            return Collections.emptyList();&#10;        }&#10;        return new ArrayList&lt;&gt;(user.getFriends());&#10;    }&#10;&#10;    public Message sendMessage(User from, List&lt;User&gt; to, String text) {&#10;        Message message = new Message(-1, from, to, text, java.time.LocalDateTime.now());&#10;        return messageRepository.save(message);&#10;    }&#10;&#10;    public Message replyMessage(User from, List&lt;User&gt; to, String text, Message replyTo) {&#10;        Message reply = new Message(-1, from, to, text, java.time.LocalDateTime.now(), replyTo);&#10;        return messageRepository.saveReply(reply);&#10;    }&#10;&#10;    public List&lt;Message&gt; getConversation(int userId, int otherUserId) {&#10;        return messageRepository.findConversation(userId, otherUserId);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package service;&#10;&#10;import domain.*;&#10;import errors.RepoError;&#10;import errors.ValidationError;&#10;import repo.EventRepository;&#10;import repo.UserRepository;&#10;import repo.PostgresUserRepository; // added&#10;import repo.PostgresEventRepository;&#10;import repo.CardRepository;&#10;import repo.MessageRepository;&#10;import util.PageResult;&#10;import util.Algorithms;&#10;import util.PasswordHasher;&#10;import validator.ValidationStrategy;&#10;&#10;import java.util.*;&#10;&#10;/**&#10; * Service layer that orchestrates repository access, validation and business&#10; * operations for the social network domain.&#10; */&#10;public class NetworkService {&#10;    private UserRepository userRepository;&#10;    private EventRepository eventRepository;&#10;    private ValidationStrategy&lt;Persoana&gt; persoanaValidator;&#10;    private ValidationStrategy&lt;Duck&gt; duckValidator;&#10;    private final Map&lt;Integer, Card&gt; cards = new HashMap&lt;&gt;();&#10;    private final CardRepository cardRepository;&#10;    private final MessageRepository messageRepository;&#10;&#10;    /**&#10;     * Construct the NetworkService with required dependencies.&#10;     *&#10;     * @param userRepository repository for users&#10;     * @param eventRepository repository for events&#10;     * @param persoanaValidator validator for Persoana instances&#10;     * @param duckValidator validator for Duck instances&#10;     * @param cardRepository repository for cards&#10;     * @param messageRepository repository for messages&#10;     */&#10;    public NetworkService(UserRepository userRepository, EventRepository eventRepository, ValidationStrategy&lt;Persoana&gt; persoanaValidator, ValidationStrategy&lt;Duck&gt; duckValidator, CardRepository cardRepository, MessageRepository messageRepository) {&#10;        this.userRepository = userRepository;&#10;        this.eventRepository = eventRepository;&#10;        this.persoanaValidator = persoanaValidator;&#10;        this.duckValidator = duckValidator;&#10;        this.cardRepository = cardRepository;&#10;        this.messageRepository = messageRepository;&#10;        if(cardRepository != null){&#10;            for (Card card : cardRepository.findAll()) {&#10;                cards.put(card.getId(), card);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Add a new user to the network after validating it.&#10;     *&#10;     * @param user the user to add (Persoana or Duck)&#10;     * @return the saved user&#10;     * @throws ValidationError when validation fails&#10;     * @throws RepoError when repository rejects the save (e.g. duplicate id)&#10;     */&#10;    public User addUser(User user) throws ValidationError, RepoError {&#10;        if(user instanceof Persoana){&#10;            persoanaValidator.validate((Persoana) user);&#10;        }&#10;        else if(user instanceof Duck){&#10;            duckValidator.validate((Duck) user);&#10;        }&#10;        else{&#10;            throw new ValidationError(&quot;Unknown user type&quot;);&#10;        }&#10;        User toPersist = hashPassword(user);&#10;        return userRepository.save(toPersist);&#10;    }&#10;&#10;    private User hashPassword(User user) {&#10;        user.setPassword(PasswordHasher.hash(user.getPassword()));&#10;        return user;&#10;    }&#10;&#10;    public User login(String email, String password) {&#10;        User found = userRepository.findByEmail(email == null ? null : email.toLowerCase());&#10;        if (found == null) {&#10;            throw new RepoError(&quot;Invalid credentials&quot;);&#10;        }&#10;        String stored = found.getPassword();&#10;        boolean isHashed = stored != null &amp;&amp; stored.startsWith(&quot;$2&quot;);&#10;        boolean authenticated;&#10;        if (isHashed) {&#10;            authenticated = PasswordHasher.matches(password, stored);&#10;        } else {&#10;            authenticated = Objects.equals(password, stored);&#10;            if (authenticated) {&#10;                String newHash = PasswordHasher.hash(password);&#10;                userRepository.updatePassword(found.getId(), newHash);&#10;                found.setPassword(newHash);&#10;            }&#10;        }&#10;        if (!authenticated) {&#10;            throw new RepoError(&quot;Invalid credentials&quot;);&#10;        }&#10;        return reloadUser(found.getId());&#10;    }&#10;&#10;    /**&#10;     * Remove a user by id and clean up references from other users' friend lists.&#10;     * Also removes a duck from all cards where it appears.&#10;     *&#10;     * @param id the id of the user to remove&#10;     * @return the removed user&#10;     * @throws RepoError when the user does not exist&#10;     */&#10;    public User removeUser(Integer id){&#10;        User userToRemove=userRepository.delete(id);&#10;        if(userToRemove==null){&#10;            throw new RepoError(&quot;User with id &quot;+id+&quot; not found&quot;);&#10;        }&#10;        for (User u: userRepository.findAll()) {&#10;            u.removeFriend(userToRemove);&#10;        }&#10;        // also remove from cards if it's a Duck&#10;        if (userToRemove instanceof Duck) {&#10;            Duck d = (Duck) userToRemove;&#10;            for (Card c : cards.values()) {&#10;                c.removeDuck(d);&#10;            }&#10;            if (cardRepository != null) {&#10;                cardRepository.removeDuckFromAll(d.getId());&#10;            }&#10;        }&#10;        return userToRemove;&#10;    }&#10;&#10;    /**&#10;     * Create a mutual friendship between two users identified by their ids.&#10;     *&#10;     * @param id1 first user's id&#10;     * @param id2 second user's id&#10;     * @throws RepoError when either user is not found&#10;     */&#10;    public void addFriendship(Integer id1, Integer id2){&#10;        User user1=userRepository.findOne(id1);&#10;        User user2=userRepository.findOne(id2);&#10;        if(user1==null){&#10;            throw new RepoError(&quot;User with id &quot;+id1+&quot; not found&quot;);&#10;        }&#10;        if(user2==null){&#10;            throw new RepoError(&quot;User with id &quot;+id2+&quot; not found&quot;);&#10;        }&#10;        user1.addFriend(user2);&#10;        user2.addFriend(user1);&#10;        if(userRepository instanceof PostgresUserRepository pr){&#10;            pr.saveFriendship(id1, id2);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Remove a mutual friendship between two users (if present).&#10;     *&#10;     * @param id1 first user's id&#10;     * @param id2 second user's id&#10;     */&#10;    public void removeFriendship(Integer id1, Integer id2){&#10;        User user1=userRepository.findOne(id1);&#10;        User user2=userRepository.findOne(id2);&#10;        if(user1!=null){&#10;            user1.removeFriend(user2);&#10;        }&#10;        if(user2!=null){&#10;            user2.removeFriend(user1);&#10;        }&#10;        if(userRepository instanceof PostgresUserRepository pr){&#10;            pr.deleteFriendship(id1, id2);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Retrieve all users from the repository, optionally filtering by user type.&#10;     *&#10;     * @param userType optional class type to filter users (e.g., Persoana.class or Duck.class)&#10;     * @return list of users matching the filter&#10;     */&#10;    public List&lt;User&gt; getAllUsers(Class&lt;? extends User&gt; userType){&#10;        List&lt;User&gt; result = new ArrayList&lt;&gt;();&#10;        for (User u : userRepository.findAll()) {&#10;            if (userType == null || userType.isInstance(u)) {&#10;                result.add(u);&#10;            }&#10;        }&#10;        return result;&#10;    }&#10;&#10;    public PageResult&lt;Duck&gt; getDucksPage(int pageIndex, int pageSize, TipRata filter) {&#10;        return userRepository.findDuckPage(pageIndex, pageSize, filter);&#10;    }&#10;&#10;    public Iterable&lt;Duck&gt; getAllDucks() {&#10;        return userRepository.findAllDucks();&#10;    }&#10;&#10;    /**&#10;     * Compute the number of connected components (communities) in the network.&#10;     *&#10;     * @return number of communities&#10;     */&#10;    public int getNumberOfCommunities(){&#10;        Set&lt;User&gt; visited=new HashSet&lt;&gt;();&#10;        int communities=0;&#10;        for (User user: userRepository.findAll()) {&#10;            if(!visited.contains(user)){&#10;                communities++;&#10;                Algorithms.dfs(user, visited);&#10;            }&#10;        }&#10;        return communities;&#10;    }&#10;&#10;    /**&#10;     * Find the community with the largest diameter (most social community).&#10;     * The method returns the list of users in the community with the maximum&#10;     * shortest-path diameter.&#10;     *&#10;     * @return list of users forming the most social community&#10;     */&#10;    public List&lt;User&gt; getMostSocialCommunity() {&#10;        Set&lt;User&gt; visitedGlobal = new HashSet&lt;&gt;();&#10;        List&lt;User&gt; bestCommunity = new ArrayList&lt;&gt;();&#10;        int maxDiameter = -1;&#10;        for (User user : userRepository.findAll()) {&#10;            if (!visitedGlobal.contains(user)) {&#10;                Set&lt;User&gt; currentCommunitySet = new HashSet&lt;&gt;();&#10;                Algorithms.dfs(user, currentCommunitySet); // Gsete toi membrii&#10;                visitedGlobal.addAll(currentCommunitySet);&#10;                List&lt;User&gt; currentCommunityList = new ArrayList&lt;&gt;(currentCommunitySet);&#10;                int currentDiameter = Algorithms.getDiameter(currentCommunityList);&#10;                if (currentDiameter &gt; maxDiameter) {&#10;                    maxDiameter = currentDiameter;&#10;                    bestCommunity = currentCommunityList;&#10;                }&#10;            }&#10;        }&#10;        System.out.println(&quot;Diametrul maxim gsit: &quot; + maxDiameter);&#10;        return bestCommunity;&#10;    }&#10;&#10;    // CARD operations&#10;    /**&#10;     * Create a card (flock) that can contain ducks and compute their average performance.&#10;     *&#10;     * @param numeCard card name&#10;     * @return created {@link Card}&#10;     */&#10;    public Card createCard(String numeCard){&#10;        Card persisted;&#10;        if (cardRepository != null) {&#10;            // persist first to obtain DB-generated id&#10;            persisted = cardRepository.save(new Card(-1, numeCard));&#10;        } else {&#10;            // fallback to in-memory id assignment&#10;            int newId = cards.keySet().stream().mapToInt(Integer::intValue).max().orElse(0) + 1;&#10;            persisted = new Card(newId, numeCard);&#10;        }&#10;        cards.put(persisted.getId(), persisted);&#10;        return persisted;&#10;    }&#10;&#10;    /**&#10;     * @return view of all created cards&#10;     */&#10;    public Collection&lt;Card&gt; getAllCards(){&#10;        return cards.values();&#10;    }&#10;&#10;    /**&#10;     * Add a duck to a card by their ids.&#10;     *&#10;     * @param cardId card id&#10;     * @param duckId duck user id&#10;     */&#10;    public void addDuckToCard(int cardId, int duckId){&#10;        Card c = cards.get(cardId);&#10;        if(c==null) throw new RepoError(&quot;Card not found&quot;);&#10;        User u = userRepository.findOne(duckId);&#10;        if(!(u instanceof Duck)) throw new RepoError(&quot;User is not a duck or not found&quot;);&#10;        c.addDuck((Duck) u);&#10;        if(cardRepository != null) {&#10;            cardRepository.addDuck(cardId, duckId);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Remove a duck from a card by their ids.&#10;     *&#10;     * @param cardId card id&#10;     * @param duckId duck user id&#10;     */&#10;    public void removeDuckFromCard(int cardId, int duckId){&#10;        Card c = cards.get(cardId);&#10;        if(c==null) throw new RepoError(&quot;Card not found&quot;);&#10;        User u = userRepository.findOne(duckId);&#10;        if(!(u instanceof Duck)) throw new RepoError(&quot;User is not a duck or not found&quot;);&#10;        c.removeDuck((Duck) u);&#10;        if(cardRepository != null) {&#10;            cardRepository.removeDuck(cardId, duckId);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Compute the average performance value for a card.&#10;     *&#10;     * @param cardId card id&#10;     * @return average performance&#10;     */&#10;    public double getCardPerformantaMedie(int cardId){&#10;        Card c = cards.get(cardId);&#10;        if(c==null) throw new RepoError(&quot;Card not found&quot;);&#10;        return c.getPerformantaMedie();&#10;    }&#10;&#10;    // EVENT operations using repository&#10;    /**&#10;     * Create and store a race event with a specific lane count.&#10;     *&#10;     * @param name  event name&#10;     * @param lanes number of lanes (M)&#10;     * @return created {@link RaceEvent} with a DB-generated id&#10;     */&#10;    public RaceEvent createRaceEvent(String name, int lanes){&#10;        // temporary id; PostgresEventRepository should ignore/use its own sequence&#10;        RaceEvent re = new RaceEvent(-1, name, lanes);&#10;        eventRepository.save(re);&#10;        return re;&#10;    }&#10;&#10;    /**&#10;     * @return all events stored in the repository&#10;     */&#10;    public Iterable&lt;Event&gt; getAllEvents(){ return eventRepository.findAll(); }&#10;&#10;    /**&#10;     * Subscribe a user to an event by ids.&#10;     *&#10;     * @param eventId event id&#10;     * @param userId  user id&#10;     */&#10;    public void subscribeToEvent(int eventId, int userId){&#10;        Event e = eventRepository.findOne(eventId);&#10;        if(e==null) throw new RepoError(&quot;Event not found&quot;);&#10;        User u = userRepository.findOne(userId);&#10;        if(u==null) throw new RepoError(&quot;User not found&quot;);&#10;        e.subscribe(u);&#10;        if(eventRepository instanceof PostgresEventRepository pe){&#10;            pe.addSubscriber(eventId, userId);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Unsubscribe a user from an event (no-op if user or event does not exist).&#10;     *&#10;     * @param eventId event id&#10;     * @param userId  user id&#10;     */&#10;    public void unsubscribeFromEvent(int eventId, int userId){&#10;        Event e = eventRepository.findOne(eventId);&#10;        if(e==null) throw new RepoError(&quot;Event not found&quot;);&#10;        User u = userRepository.findOne(userId);&#10;        if(u!=null) {&#10;            e.unsubscribe(u);&#10;            if(eventRepository instanceof PostgresEventRepository pe){&#10;                pe.removeSubscriber(eventId, userId);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Run a race event identified by id. It gathers all users that are both Duck and Inotator,&#10;     * selects up to M participants, runs the optimizer and returns a textual report.&#10;     *&#10;     * @param eventId the race event id&#10;     * @return list of report lines (one per lane + minimal total time)&#10;     */&#10;    public List&lt;String&gt; runRace(int eventId){&#10;        Event ev = eventRepository.findOne(eventId);&#10;        if(!(ev instanceof RaceEvent)) throw new RepoError(&quot;Event is not a race&quot;);&#10;        RaceEvent re = (RaceEvent) ev;&#10;        List&lt;Duck&gt; allDucks = new ArrayList&lt;&gt;();&#10;        for (Duck duck : userRepository.findAllDucks()) {&#10;            if (duck instanceof Inotator) {&#10;                allDucks.add(duck);&#10;            }&#10;        }&#10;        re.selectParticipants(allDucks);&#10;        List&lt;String&gt; report = re.runRaceAndReport();&#10;        if(eventRepository instanceof PostgresEventRepository pe){&#10;            pe.addNotification(eventId, &quot;Race finished. Results available.&quot;);&#10;        }&#10;        return report;&#10;    }&#10;&#10;    /**&#10;     * Configure lane distances for a race event.&#10;     *&#10;     * @param eventId   race event id&#10;     * @param distances per-lane distances (exactly M values)&#10;     */&#10;    public void setRaceDistances(int eventId, double[] distances){&#10;        Event ev = eventRepository.findOne(eventId);&#10;        if(!(ev instanceof RaceEvent)) throw new errors.RepoError(&quot;Event is not a race&quot;);&#10;        ((RaceEvent) ev).setDistances(distances);&#10;    }&#10;&#10;    /**&#10;     * Get the notifications received by a specific user.&#10;     *&#10;     * @param userId id of the user&#10;     * @return unmodifiable list of messages&#10;     * @throws RepoError if the user is not found&#10;     */&#10;    public List&lt;String&gt; getUserNotifications(int userId){&#10;        User u = userRepository.findOne(userId);&#10;        if(u==null) throw new RepoError(&quot;User not found&quot;);&#10;        return u.getNotifications();&#10;    }&#10;&#10;    public void addFriendshipByEmail(String emailA, String emailB) {&#10;        User a = requireUserByEmail(emailA);&#10;        User b = requireUserByEmail(emailB);&#10;        addFriendship(a.getId(), b.getId());&#10;    }&#10;&#10;    public void removeFriendshipByEmail(String emailA, String emailB) {&#10;        User a = requireUserByEmail(emailA);&#10;        User b = requireUserByEmail(emailB);&#10;        removeFriendship(a.getId(), b.getId());&#10;    }&#10;&#10;    public User requireUserByEmail(String email) {&#10;        User user = userRepository.findByEmail(email == null ? null : email.toLowerCase());&#10;        if (user == null) {&#10;            throw new RepoError(&quot;User not found for email &quot; + email);&#10;        }&#10;        return user;&#10;    }&#10;&#10;    public User getUserByEmail(String email) {&#10;        if (email == null) {&#10;            return null;&#10;        }&#10;        return userRepository.findByEmail(email.toLowerCase());&#10;    }&#10;&#10;    public User reloadUser(int userId) {&#10;        for (User user : userRepository.findAll()) {&#10;            if (user.getId() == userId) {&#10;                return user;&#10;            }&#10;        }&#10;        return null;&#10;    }&#10;&#10;    public List&lt;User&gt; getFriendsFor(int userId) {&#10;        User user = reloadUser(userId);&#10;        if (user == null) {&#10;            return Collections.emptyList();&#10;        }&#10;        return new ArrayList&lt;&gt;(user.getFriends());&#10;    }&#10;&#10;    public Message sendMessage(User from, List&lt;User&gt; to, String text) {&#10;        Message message = new Message(-1, from, to, text, java.time.LocalDateTime.now());&#10;        return messageRepository.save(message);&#10;    }&#10;&#10;    public Message replyMessage(User from, List&lt;User&gt; to, String text, Message replyTo) {&#10;        Message reply = new Message(-1, from, to, text, java.time.LocalDateTime.now(), replyTo);&#10;        return messageRepository.saveReply(reply);&#10;    }&#10;&#10;    public List&lt;Message&gt; getConversation(int userId, int otherUserId) {&#10;        return messageRepository.findConversation(userId, otherUserId);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>